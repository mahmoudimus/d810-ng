# cython: language_level=3
# distutils: language=c++
#
# THIS FILE IS AUTO-GENERATED BY batch_pxdgen - DO NOT EDIT
# Generated: 2025-11-30 01:48:05
# Source: hexrays.hpp
#

from libc.stdint cimport int16_t, int32_t, int64_t, int8_t, uint16_t, uint32_t, uint64_t, uint8_t
from libc.stddef cimport size_t
from libcpp cimport bool as cppbool
from libc.stdio cimport FILE

cdef extern from "hexrays.hpp":
    ctypedef uint64_t asize_t
    ctypedef uint64_t ea_t
    ctypedef uint64_t flags64_t
    ctypedef uint32_t flags_t
    ctypedef int16_t int16
    ctypedef int32_t int32
    ctypedef int64_t int64
    ctypedef int64_t ssize_t
    ctypedef int64_t sval_t
    ctypedef uint8_t type_t
    ctypedef uint8_t uchar
    ctypedef uint32_t uint
    ctypedef uint16_t uint16
    ctypedef uint32_t uint32
    ctypedef uint64_t uint64
    ctypedef uint8_t uint8
    ctypedef uint64_t uval_t
    ctypedef int voff_set_t
    ctypedef int mreg_t
    ctypedef int easet_t
    ctypedef int minsn_ptr_set_t
    ctypedef int strings_t
    ctypedef uint64 uvlr_t
    ctypedef int64 svlr_t
    ctypedef int maymust_t
    ctypedef int user_numforms_t
    ctypedef int lvar_mapping_t
    ctypedef int udcall_map_t
    ctypedef int mbitmap_t
    ctypedef uint8 mopt_t
    ctypedef int user_cmts_t
    ctypedef int user_iflags_t
    ctypedef int user_unions_t
    ctypedef int user_labels_t
    ctypedef int eamap_t
    ctypedef int boundaries_t
    ctypedef int cmt_type_t
    ctypedef int iterator_word
    cdef enum:
        MAX_VLR_SIZE = 8
    cdef enum cmpop_t:
        CMP_NZ = 0
        CMP_Z = 1
        CMP_AE = 2
        CMP_B = 3
        CMP_A = 4
        CMP_BE = 5
        CMP_GT = 6
        CMP_GE = 7
        CMP_LT = 8
        CMP_LE = 9
    cdef enum merror_t:  # -------------------------------------------------------------------...
        MERR_OK = 0  # ok
        MERR_BLOCK = 1  # no error, switch to new block
        MERR_INTERR = -1  # internal error
        MERR_INSN = -2  # cannot convert to microcode
        MERR_MEM = -3  # not enough memory
        MERR_BADBLK = -4  # bad block found
        MERR_BADSP = -5  # positive sp value has been found
        MERR_PROLOG = -6  # prolog analysis failed
        MERR_SWITCH = -7  # wrong switch idiom
        MERR_EXCEPTION = -8  # exception analysis failed
        MERR_HUGESTACK = -9  # stack frame is too big
        MERR_LVARS = -10  # local variable allocation failed
        MERR_BITNESS = -11  # 16-bit functions cannot be decompiled
        MERR_BADCALL = -12  # could not determine call arguments
        MERR_BADFRAME = -13  # function frame is wrong
        MERR_UNKTYPE = -14  # undefined type %s (currently unused error code)
        MERR_BADIDB = -15  # inconsistent database information
        MERR_SIZEOF = -16  # wrong basic type sizes in compiler settings
        MERR_REDO = -17  # redecompilation has been requested
        MERR_CANCELED = -18  # decompilation has been cancelled
        MERR_RECDEPTH = -19  # max recursion depth reached during lvar allocation
        MERR_OVERLAP = -20  # variables would overlap: %s
        MERR_PARTINIT = -21  # partially initialized variable %s
        MERR_COMPLEX = -22  # too complex function
        MERR_LICENSE = -23  # no license available
        MERR_ONLY32 = -24  # only 32-bit functions can be decompiled for the current database
        MERR_ONLY64 = -25  # only 64-bit functions can be decompiled for the current database
        MERR_BUSY = -26  # already decompiling a function
        MERR_FARPTR = -27  # far memory model is supported only for pc
        MERR_EXTERN = -28  # special segments cannot be decompiled
        MERR_FUNCSIZE = -29  # too big function
        MERR_BADRANGES = -30  # bad input ranges
        MERR_BADARCH = -31  # current architecture is not supported
        MERR_DSLOT = -32  # bad instruction in the delay slot
        MERR_STOP = -33  # no error, stop the analysis
        MERR_CLOUD = -34  # cloud: %s
        MERR_EMULATOR = -35  # emulator: %s
        MERR_MAX_ERR = 35
        MERR_LOOP = -36  # internal code: redo last loop (never reported)
    cdef enum mcode_t:  # Instructions marked with *F may have the FPINSN bit set and operate...
        m_nop = 0  # nop // no operation
        m_stx = 1  # stx l, {r=sel, d=off} // store register to memory *F
        m_ldx = 2  # ldx {l=sel,r=off}, d // load register from memory *F
        m_ldc = 3  # ldc l=const, d // load constant
        m_mov = 4  # mov l, d // move *F
        m_neg = 5  # neg l, d // negate
        m_lnot = 6  # lnot l, d // logical not
        m_bnot = 7  # bnot l, d // bitwise not
        m_xds = 8  # xds l, d // extend (signed)
        m_xdu = 9  # xdu l, d // extend (unsigned)
        m_low = 10  # low l, d // take low part
        m_high = 11  # high l, d // take high part
        m_add = 12  # add l, r, d // l + r -> dst
        m_sub = 13  # sub l, r, d // l - r -> dst
        m_mul = 14  # mul l, r, d // l * r -> dst
        m_udiv = 15  # udiv l, r, d // l / r -> dst
        m_sdiv = 16  # sdiv l, r, d // l / r -> dst
        m_umod = 17  # umod l, r, d // l % r -> dst
        m_smod = 18  # smod l, r, d // l % r -> dst
        m_or = 19  # or l, r, d // bitwise or
        m_and = 20  # and l, r, d // bitwise and
        m_xor = 21  # xor l, r, d // bitwise xor
        m_shl = 22  # shl l, r, d // shift logical left
        m_shr = 23  # shr l, r, d // shift logical right
        m_sar = 24  # sar l, r, d // shift arithmetic right
        m_cfadd = 25  # cfadd l, r, d=carry // calculate carry bit of (l+r)
        m_ofadd = 26  # ofadd l, r, d=overf // calculate overflow bit of (l+r)
        m_cfshl = 27  # cfshl l, r, d=carry // calculate carry bit of (l<<r)
        m_cfshr = 28  # cfshr l, r, d=carry // calculate carry bit of (l>>r)
        m_sets = 29  # sets l, d=byte SF=1 Sign
        m_seto = 30  # seto l, r, d=byte OF=1 Overflow of (l-r)
        m_setp = 31  # setp l, r, d=byte PF=1 Unordered/Parity *F
        m_setnz = 32  # setnz l, r, d=byte ZF=0 Not Equal *F
        m_setz = 33  # setz l, r, d=byte ZF=1 Equal *F
        m_setae = 34  # setae l, r, d=byte CF=0 Unsigned Above or Equal *F
        m_setb = 35  # setb l, r, d=byte CF=1 Unsigned Below *F
        m_seta = 36  # seta l, r, d=byte CF=0 & ZF=0 Unsigned Above *F
        m_setbe = 37  # setbe l, r, d=byte CF=1 | ZF=1 Unsigned Below or Equal *F
        m_setg = 38  # setg l, r, d=byte SF=OF & ZF=0 Signed Greater
        m_setge = 39  # setge l, r, d=byte SF=OF Signed Greater or Equal
        m_setl = 40  # setl l, r, d=byte SF!=OF Signed Less
        m_setle = 41  # setle l, r, d=byte SF!=OF | ZF=1 Signed Less or Equal
        m_jcnd = 42  # jcnd l, d // d is mop_v or mop_b
        m_jnz = 43  # jnz l, r, d // ZF=0 Not Equal *F
        m_jz = 44  # jz l, r, d // ZF=1 Equal *F
        m_jae = 45  # jae l, r, d // CF=0 Unsigned Above or Equal *F
        m_jb = 46  # jb l, r, d // CF=1 Unsigned Below *F
        m_ja = 47  # ja l, r, d // CF=0 & ZF=0 Unsigned Above *F
        m_jbe = 48  # jbe l, r, d // CF=1 | ZF=1 Unsigned Below or Equal *F
        m_jg = 49  # jg l, r, d // SF=OF & ZF=0 Signed Greater
        m_jge = 50  # jge l, r, d // SF=OF Signed Greater or Equal
        m_jl = 51  # jl l, r, d // SF!=OF Signed Less
        m_jle = 52  # jle l, r, d // SF!=OF | ZF=1 Signed Less or Equal
        m_jtbl = 53  # jtbl l, r=mcases // Table jump
        m_ijmp = 54  # ijmp {r=sel, d=off} // indirect unconditional jump
        m_goto = 55  # goto l // l is mop_v or mop_b
        m_call = 56  # call l d // l is mop_v or mop_b or mop_h
        m_icall = 57  # icall {l=sel, r=off} d // indirect call
        m_ret = 58  # ret
        m_push = 59  # push l
        m_pop = 60  # pop d
        m_und = 61  # und d // undefine
        m_ext = 62  # ext in1, in2, out1 // external insn, not microcode *F
        m_f2i = 63  # f2i l, d int(l) => d; convert fp -> integer +F
        m_f2u = 64  # f2u l, d uint(l)=> d; convert fp -> uinteger +F
        m_i2f = 65  # i2f l, d fp(l) => d; convert integer -> fp +F
        m_u2f = 66  # i2f l, d fp(l) => d; convert uinteger -> fp +F
        m_f2f = 67  # f2f l, d l => d; change fp precision +F
        m_fneg = 68  # fneg l, d -l => d; change sign +F
        m_fadd = 69  # fadd l, r, d l + r => d; add +F
        m_fsub = 70  # fsub l, r, d l - r => d; subtract +F
        m_fmul = 71  # fmul l, r, d l * r => d; multiply +F
        m_fdiv = 72  # fdiv l, r, d l / r => d; divide +F
    cdef enum type_source_t:  # Type source (where the type information comes from)
        GUESSED_NONE = 0  # not guessed, specified by the user
        GUESSED_WEAK = 1  # not guessed, comes from idb
        GUESSED_FUNC = 2  # guessed as a function
        GUESSED_DATA = 3  # guessed as a data item
        TS_NOELL = 134217728  # can be used in set_type() to avoid merging into ellipsis
        TS_SHRINK = 67108864  # can be used in set_type() to prefer smaller arguments
        TS_DONTREF = 33554432  # do not mark type as referenced (referenced_types)
        TS_MASK = 234881024  # all high bits
    cdef enum side_effect_t:  # -------------------------------------------------------------------...
        NO_SIDEFF = 0  # change operand size but ignore side effects if you decide to keep t...
        WITH_SIDEFF = 1  # change operand size and handle side effects
        ONLY_SIDEFF = 2  # only handle side effects
        ANY_REGSIZE = 128  # any register size is permitted
        ANY_FPSIZE = 256  # any size of floating operand is permitted
    cdef enum funcrole_t:  # Function roles. They are used to calculate use/def lists and to rec...
        ROLE_UNK = 0  # unknown function role
        ROLE_EMPTY = 1  # empty, does not do anything (maybe spoils regs)
        ROLE_MEMSET = 2  # memset(void *dst, uchar value, size_t count);
        ROLE_MEMSET32 = 3  # memset32(void *dst, uint32 value, size_t count);
        ROLE_MEMSET64 = 4  # memset64(void *dst, uint64 value, size_t count);
        ROLE_MEMCPY = 5  # memcpy(void *dst, const void *src, size_t count);
        ROLE_STRCPY = 6  # strcpy(char *dst, const char *src);
        ROLE_STRLEN = 7  # strlen(const char *src);
        ROLE_STRCAT = 8  # strcat(char *dst, const char *src);
        ROLE_TAIL = 9  # char *tail(const char *str);
        ROLE_BUG = 10  # BUG() helper macro: never returns, causes exception
        ROLE_ALLOCA = 11  # alloca() function
        ROLE_BSWAP = 12  # bswap() function (any size)
        ROLE_PRESENT = 13  # present() function (used in patterns)
        ROLE_CONTAINING_RECORD = 14  # CONTAINING_RECORD() macro
        ROLE_FASTFAIL = 15  # __fastfail()
        ROLE_READFLAGS = 16  # __readeflags, __readcallersflags
        ROLE_IS_MUL_OK = 17  # is_mul_ok
        ROLE_SATURATED_MUL = 18  # saturated_mul
        ROLE_BITTEST = 19  # [lock] bt
        ROLE_BITTESTANDSET = 20  # [lock] bts
        ROLE_BITTESTANDRESET = 21  # [lock] btr
        ROLE_BITTESTANDCOMPLEMENT = 22  # [lock] btc
        ROLE_VA_ARG = 23  # va_arg() macro
        ROLE_VA_COPY = 24  # va_copy() function
        ROLE_VA_START = 25  # va_start() function
        ROLE_VA_END = 26  # va_end() function
        ROLE_ROL = 27  # rotate left
        ROLE_ROR = 28  # rotate right
        ROLE_CFSUB3 = 29  # carry flag after subtract with carry
        ROLE_OFSUB3 = 30  # overflow flag after subtract with carry
        ROLE_ABS = 31  # integer absolute value
        ROLE_3WAYCMP0 = 32  # 3-way compare helper, returns -1/0/1
        ROLE_3WAYCMP1 = 33  # 3-way compare helper, returns 0/1/2
        ROLE_WMEMCPY = 34  # wchar_t *wmemcpy(wchar_t *dst, const wchar_t *src, size_t n)
        ROLE_WMEMSET = 35  # wchar_t *wmemset(wchar_t *dst, wchar_t wc, size_t n)
        ROLE_WCSCPY = 36  # wchar_t *wcscpy(wchar_t *dst, const wchar_t *src);
        ROLE_WCSLEN = 37  # size_t wcslen(const wchar_t *s)
        ROLE_WCSCAT = 38  # wchar_t *wcscat(wchar_t *dst, const wchar_t *src)
        ROLE_SSE_CMP4 = 39  # e.g. _mm_cmpgt_ss
        ROLE_SSE_CMP8 = 40  # e.g. _mm_cmpgt_sd
    cdef enum mblock_type_t:  # -------------------------------------------------------------------...
        BLT_NONE = 0  # unknown block type
        BLT_STOP = 1  # stops execution regularly (must be the last block)
        BLT_0WAY = 2  # does not have successors (tail is a noret function)
        BLT_1WAY = 3  # passes execution to one block (regular or goto block)
        BLT_2WAY = 4  # passes execution to two blocks (conditional jump)
        BLT_NWAY = 5  # passes execution to many blocks (switch idiom)
        BLT_XTRN = 6  # external block (out of function address)
    cdef enum warnid_t:  # -------------------------------------------------------------------...
        WARN_VARARG_REGS = 0  # 0 cannot handle register arguments in vararg function, discarded them
        WARN_ILL_PURGED = 1  # 1 odd caller purged bytes %d, correcting
        WARN_ILL_FUNCTYPE = 2  # 2 invalid function type '%s' has been ignored
        WARN_VARARG_TCAL = 3  # 3 cannot handle tail call to vararg
        WARN_VARARG_NOSTK = 4  # 4 call vararg without local stack
        WARN_VARARG_MANY = 5  # 5 too many varargs, some ignored
        WARN_ADDR_OUTARGS = 6  # 6 cannot handle address arithmetics in outgoing argument area of st...
        WARN_DEP_UNK_CALLS = 7  # 7 found interdependent unknown calls
        WARN_ILL_ELLIPSIS = 8  # 8 erroneously detected ellipsis type has been ignored
        WARN_GUESSED_TYPE = 9  # 9 using guessed type %s;
        WARN_EXP_LINVAR = 10  # 10 failed to expand a linear variable
        WARN_WIDEN_CHAINS = 11  # 11 failed to widen chains
        WARN_BAD_PURGED = 12  # 12 inconsistent function type and number of purged bytes
        WARN_CBUILD_LOOPS = 13  # 13 too many cbuild loops
        WARN_NO_SAVE_REST = 14  # 14 could not find valid save-restore pair for %s
        WARN_ODD_INPUT_REG = 15  # 15 odd input register %s
        WARN_ODD_ADDR_USE = 16  # 16 odd use of a variable address
        WARN_MUST_RET_FP = 17  # 17 function return type is incorrect (must be floating point)
        WARN_ILL_FPU_STACK = 18  # 18 inconsistent fpu stack
        WARN_SELFREF_PROP = 19  # 19 self-referencing variable has been detected
        WARN_WOULD_OVERLAP = 20  # 20 variables would overlap: %s
        WARN_ARRAY_INARG = 21  # 21 array has been used for an input argument
        WARN_MAX_ARGS = 22  # 22 too many input arguments, some ignored
        WARN_BAD_FIELD_TYPE = 23  # 23 incorrect structure member type for %s::%s, ignored
        WARN_WRITE_CONST = 24  # 24 write access to const memory at %a has been detected
        WARN_BAD_RETVAR = 25  # 25 wrong return variable
        WARN_FRAG_LVAR = 26  # 26 fragmented variable at %s may be wrong
        WARN_HUGE_STKOFF = 27  # 27 exceedingly huge offset into the stack frame
        WARN_UNINITED_REG = 28  # 28 reference to an uninitialized register has been removed: %s
        WARN_FIXED_INSN = 29  # 29 fixed broken insn
        WARN_WRONG_VA_OFF = 30  # 30 wrong offset of va_list variable
        WARN_CR_NOFIELD = 31  # 31 CONTAINING_RECORD: no field '%s' in struct '%s' at %d
        WARN_CR_BADOFF = 32  # 32 CONTAINING_RECORD: too small offset %d for struct '%s'
        WARN_BAD_STROFF = 33  # 33 user specified stroff has not been processed: %s
        WARN_BAD_VARSIZE = 34  # 34 inconsistent variable size for '%s'
        WARN_UNSUPP_REG = 35  # 35 unsupported processor register '%s'
        WARN_UNALIGNED_ARG = 36  # 36 unaligned function argument '%s'
        WARN_BAD_STD_TYPE = 37  # 37 corrupted or unexisting local type '%s'
        WARN_BAD_CALL_SP = 38  # 38 bad sp value at call
        WARN_MISSED_SWITCH = 39  # 39 wrong markup of switch jump, skipped it
        WARN_BAD_SP = 40  # 40 positive sp value %a has been found
        WARN_BAD_STKPNT = 41  # 41 wrong sp change point
        WARN_UNDEF_LVAR = 42  # 42 variable '%s' is possibly undefined
        WARN_JUMPOUT = 43  # 43 control flows out of bounds
        WARN_BAD_VALRNG = 44  # 44 values range analysis failed
        WARN_BAD_SHADOW = 45  # 45 ignored the value written to the shadow area of the succeeding call
        WARN_OPT_VALRNG = 46  # 46 conditional instruction was optimized away because %s
        WARN_RET_LOCREF = 47  # 47 returning address of temporary local variable '%s'
        WARN_BAD_MAPDST = 48  # 48 too short map destination '%s' for variable '%s'
        WARN_BAD_INSN = 49  # 49 bad instruction
        WARN_ODD_ABI = 50  # 50 encountered odd instruction for the current ABI
        WARN_UNBALANCED_STACK = 51  # 51 unbalanced stack, ignored a potential tail call
        WARN_OPT_VALRNG2 = 52  # 52 mask 0x%X is shortened because %s <= 0x%X"
        WARN_OPT_VALRNG3 = 53  # 53 masking with 0X%X was optimized away because %s <= 0x%X
        WARN_OPT_USELESS_JCND = 54  # 54 simplified comparisons for '%s': %s became %s
        WARN_SUBFRAME_OVERFLOW = 55  # 55 call arguments overflow the function chunk frame
        WARN_OPT_VALRNG4 = 56  # 56 the cases %s were optimized away because %s
        WARN_MAX = 57  # may be used in notes as a placeholder when the warning id is not av...
    cdef enum mba_maturity_t:  # -------------------------------------------------------------------...
        MMAT_ZERO = 0  # microcode does not exist
        MMAT_GENERATED = 1  # generated microcode
        MMAT_PREOPTIMIZED = 2  # preoptimized pass is complete
        MMAT_LOCOPT = 3  # local optimization of each basic block is complete. control flow gr...
        MMAT_CALLS = 4  # detected call arguments. see also hxe_calls_done
        MMAT_GLBOPT1 = 5  # performed the first pass of global optimization
        MMAT_GLBOPT2 = 6  # most global optimization passes are done
        MMAT_GLBOPT3 = 7  # completed all global optimization. microcode is fixed now.
        MMAT_LVARS = 8  # allocated local variables
    cdef enum memreg_index_t:  # -------------------------------------------------------------------...
        MMIDX_GLBLOW = 0  # global memory: low part
        MMIDX_LVARS = 1  # stack: local variables
        MMIDX_RETADDR = 2  # stack: return address
        MMIDX_SHADOW = 3  # stack: shadow arguments
        MMIDX_ARGS = 4  # stack: regular stack arguments
        MMIDX_GLBHIGH = 5  # global memory: high part
    cdef enum gctype_t:  # -------------------------------------------------------------------...
        GC_REGS_AND_STKVARS = 0  # registers and stkvars (restricted memory only)
        GC_ASR = 1  # all the above and assertions
        GC_XDSU = 2  # only registers calculated with FULL_XDSU
        GC_END = 3  # number of chain types
        GC_DIRTY_ALL = 63  # bitmask to represent all chains
    cdef enum ctype_t:  # -------------------------------------------------------------------...
        cot_empty = 0
        cot_comma = 1  # x, y
        cot_asg = 2  # x = y
        cot_asgbor = 3  # x |= y
        cot_asgxor = 4  # x ^= y
        cot_asgband = 5  # x &= y
        cot_asgadd = 6  # x += y
        cot_asgsub = 7  # x -= y
        cot_asgmul = 8  # x *= y
        cot_asgsshr = 9  # x >>= y signed
        cot_asgushr = 10  # x >>= y unsigned
        cot_asgshl = 11  # x <<= y
        cot_asgsdiv = 12  # x /= y signed
        cot_asgudiv = 13  # x /= y unsigned
        cot_asgsmod = 14  # x %= y signed
        cot_asgumod = 15  # x %= y unsigned
        cot_tern = 16  # x ? y : z
        cot_lor = 17  # x || y
        cot_land = 18  # x && y
        cot_bor = 19  # x | y
        cot_xor = 20  # x ^ y
        cot_band = 21  # x & y
        cot_eq = 22  # x == y int or fpu (see EXFL_FPOP)
        cot_ne = 23  # x != y int or fpu (see EXFL_FPOP)
        cot_sge = 24  # x >= y signed or fpu (see EXFL_FPOP)
        cot_uge = 25  # x >= y unsigned
        cot_sle = 26  # x <= y signed or fpu (see EXFL_FPOP)
        cot_ule = 27  # x <= y unsigned
        cot_sgt = 28  # x > y signed or fpu (see EXFL_FPOP)
        cot_ugt = 29  # x > y unsigned
        cot_slt = 30  # x < y signed or fpu (see EXFL_FPOP)
        cot_ult = 31  # x < y unsigned
        cot_sshr = 32  # x >> y signed
        cot_ushr = 33  # x >> y unsigned
        cot_shl = 34  # x << y
        cot_add = 35  # x + y
        cot_sub = 36  # x - y
        cot_mul = 37  # x * y
        cot_sdiv = 38  # x / y signed
        cot_udiv = 39  # x / y unsigned
        cot_smod = 40  # x % y signed
        cot_umod = 41  # x % y unsigned
        cot_fadd = 42  # x + y fp
        cot_fsub = 43  # x - y fp
        cot_fmul = 44  # x * y fp
        cot_fdiv = 45  # x / y fp
        cot_fneg = 46  # -x fp
        cot_neg = 47  # -x
        cot_cast = 48  # (type)x
        cot_lnot = 49  # !x
        cot_bnot = 50  # ~x
        cot_ptr = 51  # *x, access size in 'ptrsize'
        cot_ref = 52  # &x
        cot_postinc = 53  # x++
        cot_postdec = 54  # x--
        cot_preinc = 55  # ++x
        cot_predec = 56  # --x
        cot_call = 57  # x(...)
        cot_idx = 58  # x[y]
        cot_memref = 59  # x.m
        cot_memptr = 60  # x->m, access size in 'ptrsize'
        cot_num = 61  # n
        cot_fnum = 62  # fpc
        cot_str = 63  # string constant (user representation)
        cot_obj = 64  # obj_ea
        cot_var = 65  # v
        cot_insn = 66  # instruction in expression, internal representation only
        cot_sizeof = 67  # sizeof(x)
        cot_helper = 68  # arbitrary name
        cot_type = 69  # arbitrary type
        cot_last = 69
        cit_empty = 70  # instruction types start here
        cit_block = 71  # block-statement: { ... }
        cit_expr = 72  # expression-statement: expr;
        cit_if = 73  # if-statement
        cit_for = 74  # for-statement
        cit_while = 75  # while-statement
        cit_do = 76  # do-statement
        cit_switch = 77  # switch-statement
        cit_break = 78  # break-statement
        cit_continue = 79  # continue-statement
        cit_return = 80  # return-statement
        cit_goto = 81  # goto-statement
        cit_asm = 82  # asm-statement
        cit_try = 83  # C++ try-statement
        cit_throw = 84  # C++ throw-statement
        cit_end = 85
    cdef enum ctree_maturity_t:  # Ctree maturity level. The level will increase as we switch from one...
        CMAT_ZERO = 0  # does not exist
        CMAT_BUILT = 1  # just generated
        CMAT_TRANS1 = 2  # applied first wave of transformations
        CMAT_NICE = 3  # nicefied expressions
        CMAT_TRANS2 = 4  # applied second wave of transformations
        CMAT_CPA = 5  # corrected pointer arithmetic
        CMAT_TRANS3 = 6  # applied third wave of transformations
        CMAT_CASTED = 7  # added necessary casts
        CMAT_FINAL = 8  # ready-to-use
    cdef enum item_preciser_t:  # -------------------------------------------------------------------...
        ITP_EMPTY = 0  # nothing
        ITP_ARG1 = 1  # , (64 entries are reserved for 64 call arguments)
        ITP_ARG64 = 64  # ,
        ITP_BRACE1 = 65  # (
        ITP_INNER_LAST = 65
        ITP_ASM = 66  # __asm-line
        ITP_ELSE = 67  # else-line
        ITP_DO = 68  # do-line
        ITP_SEMI = 69  # semicolon
        ITP_CURLY1 = 70  # {
        ITP_CURLY2 = 71  # }
        ITP_BRACE2 = 72  # )
        ITP_COLON = 73  # : (label)
        ITP_BLOCK1 = 74  # opening block comment. this comment is printed before the item (oth...
        ITP_BLOCK2 = 75  # closing block comment.
        ITP_TRY = 76  # C++ try statement
        ITP_CASE = 1073741824  # bit for switch cases
        ITP_SIGN = 536870912  # if this bit is set too, then we have a negative case value this is ...
    cdef enum cmt_retrieval_type_t:  # Comment retrieval type. Ctree remembers what comments have already ...
        RETRIEVE_ONCE = 0  # Retrieve comment if it has not been used yet
        RETRIEVE_ALWAYS = 1  # Retrieve comment even if it has been used
    cdef enum use_curly_t:  # Should curly braces be printed?
        CALC_CURLY_BRACES = 0  # print curly braces if necessary
        NO_CURLY_BRACES = 1  # don't print curly braces
        USE_CURLY_BRACES = 2  # print curly braces without any checks
    cdef enum cursor_item_type_t:  # Type of the cursor item.
        VDI_NONE = 0  # undefined
        VDI_EXPR = 1  # c-tree item
        VDI_LVAR = 2  # declaration of local variable
        VDI_FUNC = 3  # the function itself (the very first line with the function prototype)
        VDI_TAIL = 4  # cursor is at (beyond) the line end (commentable line)
    cdef enum allow_unused_labels_t:  # Unused label disposition.
        FORBID_UNUSED_LABELS = 0  # Unused labels cause interr
        ALLOW_UNUSED_LABELS = 1  # Unused labels are permitted
    cdef enum hexrays_event_t:  # Decompiler events. Use install_hexrays_callback() to install a hand...
        hxe_flowchart = 0  # Flowchart has been generated.
        hxe_stkpnts = 1  # SP change points have been calculated.
        hxe_prolog = 2  # Prolog analysis has been finished.
        hxe_microcode = 3  # Microcode has been generated.
        hxe_preoptimized = 4  # Microcode has been preoptimized.
        hxe_locopt = 5  # Basic block level optimization has been finished.
        hxe_prealloc = 6  # Local variables: preallocation step begins.
        hxe_glbopt = 7  # Global optimization has been finished. If microcode is modified, ME...
        hxe_pre_structural = 8  # Structure analysis is starting.
        hxe_structural = 9  # Structural analysis has been finished.
        hxe_maturity = 10  # Ctree maturity level is being changed.
        hxe_interr = 11  # Internal error has occurred.
        hxe_combine = 12  # Trying to combine instructions of basic block.
        hxe_print_func = 13  # Printing ctree and generating text.
        hxe_func_printed = 14  # Function text has been generated. Plugins may modify the text in cf...
        hxe_resolve_stkaddrs = 15  # The optimizer is about to resolve stack addresses.
        hxe_build_callinfo = 16  # Analyzing a call instruction.
        hxe_callinfo_built = 17  # A call instruction has been anallyzed.
        hxe_calls_done = 18  # All calls have been analyzed.
        hxe_begin_inlining = 19  # Starting to inline outlined functions.
        hxe_inlining_func = 20  # A set of ranges is going to be inlined.
        hxe_inlined_func = 21  # A set of ranges got inlined.
        hxe_collect_warnings = 22  # Collect warning messages from plugins. These warnings will be displ...
        hxe_open_pseudocode = 100  # User interface related events:
        hxe_switch_pseudocode = 101  # Existing pseudocode view has been reloaded with a new function. Its...
        hxe_refresh_pseudocode = 102  # Existing pseudocode text has been refreshed. Adding/removing pseudo...
        hxe_close_pseudocode = 103  # Pseudocode view is being closed.
        hxe_keyboard = 104  # Keyboard has been hit.
        hxe_right_click = 105  # Mouse right click. Use hxe_populating_popup instead, in case you wa...
        hxe_double_click = 106  # Mouse double click.
        hxe_curpos = 107  # Current cursor position has been changed. (for example, by left-cli...
        hxe_create_hint = 108  # Create a hint for the current item.
        hxe_text_ready = 109  # Decompiled text is ready.
        hxe_populating_popup = 110  # Populating popup menu. We can add menu items now.
        lxe_lvar_name_changed = 111  # Local variable got renamed.
        lxe_lvar_type_changed = 112  # Local variable type got changed.
        lxe_lvar_cmt_changed = 113  # Local variable comment got changed.
        lxe_lvar_mapping_changed = 114  # Local variable mapping got changed.
        hxe_cmt_changed = 115  # Comment got changed.
        hxe_mba_maturity = 116  # Maturity level of an MBA was changed.
    cdef enum input_device_t:  # Type of the input device. How the user command has been invoked
        USE_KEYBOARD = 0  # Keyboard
        USE_MOUSE = 1  # Mouse
    cdef enum hexcall_t:  # API call numbers
        hx_user_numforms_begin = 0
        hx_user_numforms_end = 1
        hx_user_numforms_next = 2
        hx_user_numforms_prev = 3
        hx_user_numforms_first = 4
        hx_user_numforms_second = 5
        hx_user_numforms_find = 6
        hx_user_numforms_insert = 7
        hx_user_numforms_erase = 8
        hx_user_numforms_clear = 9
        hx_user_numforms_size = 10
        hx_user_numforms_free = 11
        hx_user_numforms_new = 12
        hx_lvar_mapping_begin = 13
        hx_lvar_mapping_end = 14
        hx_lvar_mapping_next = 15
        hx_lvar_mapping_prev = 16
        hx_lvar_mapping_first = 17
        hx_lvar_mapping_second = 18
        hx_lvar_mapping_find = 19
        hx_lvar_mapping_insert = 20
        hx_lvar_mapping_erase = 21
        hx_lvar_mapping_clear = 22
        hx_lvar_mapping_size = 23
        hx_lvar_mapping_free = 24
        hx_lvar_mapping_new = 25
        hx_udcall_map_begin = 26
        hx_udcall_map_end = 27
        hx_udcall_map_next = 28
        hx_udcall_map_prev = 29
        hx_udcall_map_first = 30
        hx_udcall_map_second = 31
        hx_udcall_map_find = 32
        hx_udcall_map_insert = 33
        hx_udcall_map_erase = 34
        hx_udcall_map_clear = 35
        hx_udcall_map_size = 36
        hx_udcall_map_free = 37
        hx_udcall_map_new = 38
        hx_user_cmts_begin = 39
        hx_user_cmts_end = 40
        hx_user_cmts_next = 41
        hx_user_cmts_prev = 42
        hx_user_cmts_first = 43
        hx_user_cmts_second = 44
        hx_user_cmts_find = 45
        hx_user_cmts_insert = 46
        hx_user_cmts_erase = 47
        hx_user_cmts_clear = 48
        hx_user_cmts_size = 49
        hx_user_cmts_free = 50
        hx_user_cmts_new = 51
        hx_user_iflags_begin = 52
        hx_user_iflags_end = 53
        hx_user_iflags_next = 54
        hx_user_iflags_prev = 55
        hx_user_iflags_first = 56
        hx_user_iflags_second = 57
        hx_user_iflags_find = 58
        hx_user_iflags_insert = 59
        hx_user_iflags_erase = 60
        hx_user_iflags_clear = 61
        hx_user_iflags_size = 62
        hx_user_iflags_free = 63
        hx_user_iflags_new = 64
        hx_user_unions_begin = 65
        hx_user_unions_end = 66
        hx_user_unions_next = 67
        hx_user_unions_prev = 68
        hx_user_unions_first = 69
        hx_user_unions_second = 70
        hx_user_unions_find = 71
        hx_user_unions_insert = 72
        hx_user_unions_erase = 73
        hx_user_unions_clear = 74
        hx_user_unions_size = 75
        hx_user_unions_free = 76
        hx_user_unions_new = 77
        hx_user_labels_begin = 78
        hx_user_labels_end = 79
        hx_user_labels_next = 80
        hx_user_labels_prev = 81
        hx_user_labels_first = 82
        hx_user_labels_second = 83
        hx_user_labels_find = 84
        hx_user_labels_insert = 85
        hx_user_labels_erase = 86
        hx_user_labels_clear = 87
        hx_user_labels_size = 88
        hx_user_labels_free = 89
        hx_user_labels_new = 90
        hx_eamap_begin = 91
        hx_eamap_end = 92
        hx_eamap_next = 93
        hx_eamap_prev = 94
        hx_eamap_first = 95
        hx_eamap_second = 96
        hx_eamap_find = 97
        hx_eamap_insert = 98
        hx_eamap_erase = 99
        hx_eamap_clear = 100
        hx_eamap_size = 101
        hx_eamap_free = 102
        hx_eamap_new = 103
        hx_boundaries_begin = 104
        hx_boundaries_end = 105
        hx_boundaries_next = 106
        hx_boundaries_prev = 107
        hx_boundaries_first = 108
        hx_boundaries_second = 109
        hx_boundaries_find = 110
        hx_boundaries_insert = 111
        hx_boundaries_erase = 112
        hx_boundaries_clear = 113
        hx_boundaries_size = 114
        hx_boundaries_free = 115
        hx_boundaries_new = 116
        hx_block_chains_begin = 117
        hx_block_chains_end = 118
        hx_block_chains_next = 119
        hx_block_chains_prev = 120
        hx_block_chains_get = 121
        hx_block_chains_find = 122
        hx_block_chains_insert = 123
        hx_block_chains_erase = 124
        hx_block_chains_clear = 125
        hx_block_chains_size = 126
        hx_block_chains_free = 127
        hx_block_chains_new = 128
        hx_hexrays_alloc = 129
        hx_hexrays_free = 130
        hx_valrng_t_clear = 131
        hx_valrng_t_copy = 132
        hx_valrng_t_assign = 133
        hx_valrng_t_compare = 134
        hx_valrng_t_set_eq = 135
        hx_valrng_t_set_cmp = 136
        hx_valrng_t_reduce_size = 137
        hx_valrng_t_intersect_with = 138
        hx_valrng_t_unite_with = 139
        hx_valrng_t_inverse = 140
        hx_valrng_t_has = 141
        hx_valrng_t_print = 142
        hx_valrng_t_dstr = 143
        hx_valrng_t_cvt_to_single_value = 144
        hx_valrng_t_cvt_to_cmp = 145
        hx_get_merror_desc = 146
        hx_must_mcode_close_block = 147
        hx_is_mcode_propagatable = 148
        hx_negate_mcode_relation = 149
        hx_swap_mcode_relation = 150
        hx_get_signed_mcode = 151
        hx_get_unsigned_mcode = 152
        hx_mcode_modifies_d = 153
        hx_operand_locator_t_compare = 154
        hx_vd_printer_t_print = 155
        hx_file_printer_t_print = 156
        hx_qstring_printer_t_print = 157
        hx_dstr = 158
        hx_is_type_correct = 159
        hx_is_small_udt = 160
        hx_is_nonbool_type = 161
        hx_is_bool_type = 162
        hx_partial_type_num = 163
        hx_get_float_type = 164
        hx_get_int_type_by_width_and_sign = 165
        hx_get_unk_type = 166
        hx_dummy_ptrtype = 167
        hx_get_member_type = 168
        hx_make_pointer = 169
        hx_create_typedef = 170
        hx_get_type = 171
        hx_set_type = 172
        hx_vdloc_t_dstr = 173
        hx_vdloc_t_compare = 174
        hx_vdloc_t_is_aliasable = 175
        hx_print_vdloc = 176
        hx_arglocs_overlap = 177
        hx_lvar_locator_t_compare = 178
        hx_lvar_locator_t_dstr = 179
        hx_lvar_t_dstr = 180
        hx_lvar_t_is_promoted_arg = 181
        hx_lvar_t_accepts_type = 182
        hx_lvar_t_set_lvar_type = 183
        hx_lvar_t_set_width = 184
        hx_lvar_t_append_list = 185
        hx_lvar_t_append_list_ = 186
        hx_lvars_t_find_stkvar = 187
        hx_lvars_t_find = 188
        hx_lvars_t_find_lvar = 189
        hx_restore_user_lvar_settings = 190
        hx_save_user_lvar_settings = 191
        hx_modify_user_lvars = 192
        hx_modify_user_lvar_info = 193
        hx_locate_lvar = 194
        hx_restore_user_defined_calls = 195
        hx_save_user_defined_calls = 196
        hx_parse_user_call = 197
        hx_convert_to_user_call = 198
        hx_install_microcode_filter = 199
        hx_udc_filter_t_cleanup = 200
        hx_udc_filter_t_init = 201
        hx_udc_filter_t_apply = 202
        hx_bitset_t_bitset_t = 203
        hx_bitset_t_copy = 204
        hx_bitset_t_add = 205
        hx_bitset_t_add_ = 206
        hx_bitset_t_add__ = 207
        hx_bitset_t_sub = 208
        hx_bitset_t_sub_ = 209
        hx_bitset_t_sub__ = 210
        hx_bitset_t_cut_at = 211
        hx_bitset_t_shift_down = 212
        hx_bitset_t_has = 213
        hx_bitset_t_has_all = 214
        hx_bitset_t_has_any = 215
        hx_bitset_t_dstr = 216
        hx_bitset_t_empty = 217
        hx_bitset_t_count = 218
        hx_bitset_t_count_ = 219
        hx_bitset_t_last = 220
        hx_bitset_t_fill_with_ones = 221
        hx_bitset_t_fill_gaps = 222
        hx_bitset_t_has_common = 223
        hx_bitset_t_intersect = 224
        hx_bitset_t_is_subset_of = 225
        hx_bitset_t_compare = 226
        hx_bitset_t_goup = 227
        hx_ivl_t_dstr = 228
        hx_ivl_t_compare = 229
        hx_ivlset_t_add = 230
        hx_ivlset_t_add_ = 231
        hx_ivlset_t_addmasked = 232
        hx_ivlset_t_sub = 233
        hx_ivlset_t_sub_ = 234
        hx_ivlset_t_has_common = 235
        hx_ivlset_t_print = 236
        hx_ivlset_t_dstr = 237
        hx_ivlset_t_count = 238
        hx_ivlset_t_has_common_ = 239
        hx_ivlset_t_contains = 240
        hx_ivlset_t_includes = 241
        hx_ivlset_t_intersect = 242
        hx_ivlset_t_compare = 243
        hx_rlist_t_print = 244
        hx_rlist_t_dstr = 245
        hx_mlist_t_addmem = 246
        hx_mlist_t_print = 247
        hx_mlist_t_dstr = 248
        hx_mlist_t_compare = 249
        hx_get_temp_regs = 250
        hx_is_kreg = 251
        hx_reg2mreg = 252
        hx_mreg2reg = 253
        hx_get_mreg_name = 254
        hx_install_optinsn_handler = 255
        hx_remove_optinsn_handler = 256
        hx_install_optblock_handler = 257
        hx_remove_optblock_handler = 258
        hx_simple_graph_t_compute_dominators = 259
        hx_simple_graph_t_compute_immediate_dominators = 260
        hx_simple_graph_t_depth_first_preorder = 261
        hx_simple_graph_t_depth_first_postorder = 262
        hx_simple_graph_t_goup = 263
        hx_mutable_graph_t_resize = 264
        hx_mutable_graph_t_goup = 265
        hx_mutable_graph_t_del_edge = 266
        hx_lvar_ref_t_compare = 267
        hx_lvar_ref_t_var = 268
        hx_stkvar_ref_t_compare = 269
        hx_stkvar_ref_t_get_stkvar = 270
        hx_fnumber_t_print = 271
        hx_fnumber_t_dstr = 272
        hx_mop_t_copy = 273
        hx_mop_t_assign = 274
        hx_mop_t_swap = 275
        hx_mop_t_erase = 276
        hx_mop_t_print = 277
        hx_mop_t_dstr = 278
        hx_mop_t_create_from_mlist = 279
        hx_mop_t_create_from_ivlset = 280
        hx_mop_t_create_from_vdloc = 281
        hx_mop_t_create_from_scattered_vdloc = 282
        hx_mop_t_create_from_insn = 283
        hx_mop_t_make_number = 284
        hx_mop_t_make_fpnum = 285
        hx_mop_t__make_gvar = 286
        hx_mop_t_make_gvar = 287
        hx_mop_t_make_reg_pair = 288
        hx_mop_t_make_helper = 289
        hx_mop_t_is_bit_reg = 290
        hx_mop_t_may_use_aliased_memory = 291
        hx_mop_t_is01 = 292
        hx_mop_t_is_sign_extended_from = 293
        hx_mop_t_is_zero_extended_from = 294
        hx_mop_t_equal_mops = 295
        hx_mop_t_lexcompare = 296
        hx_mop_t_for_all_ops = 297
        hx_mop_t_for_all_scattered_submops = 298
        hx_mop_t_is_constant = 299
        hx_mop_t_get_stkoff = 300
        hx_mop_t_make_low_half = 301
        hx_mop_t_make_high_half = 302
        hx_mop_t_make_first_half = 303
        hx_mop_t_make_second_half = 304
        hx_mop_t_shift_mop = 305
        hx_mop_t_change_size = 306
        hx_mop_t_preserve_side_effects = 307
        hx_mop_t_apply_ld_mcode = 308
        hx_mcallarg_t_print = 309
        hx_mcallarg_t_dstr = 310
        hx_mcallarg_t_set_regarg = 311
        hx_mcallinfo_t_lexcompare = 312
        hx_mcallinfo_t_set_type = 313
        hx_mcallinfo_t_get_type = 314
        hx_mcallinfo_t_print = 315
        hx_mcallinfo_t_dstr = 316
        hx_mcases_t_compare = 317
        hx_mcases_t_print = 318
        hx_mcases_t_dstr = 319
        hx_vivl_t_extend_to_cover = 320
        hx_vivl_t_intersect = 321
        hx_vivl_t_print = 322
        hx_vivl_t_dstr = 323
        hx_chain_t_print = 324
        hx_chain_t_dstr = 325
        hx_chain_t_append_list = 326
        hx_chain_t_append_list_ = 327
        hx_block_chains_t_get_chain = 328
        hx_block_chains_t_print = 329
        hx_block_chains_t_dstr = 330
        hx_graph_chains_t_for_all_chains = 331
        hx_graph_chains_t_release = 332
        hx_minsn_t_init = 333
        hx_minsn_t_copy = 334
        hx_minsn_t_set_combined = 335
        hx_minsn_t_swap = 336
        hx_minsn_t_print = 337
        hx_minsn_t_dstr = 338
        hx_minsn_t_setaddr = 339
        hx_minsn_t_optimize_subtree = 340
        hx_minsn_t_for_all_ops = 341
        hx_minsn_t_for_all_insns = 342
        hx_minsn_t__make_nop = 343
        hx_minsn_t_equal_insns = 344
        hx_minsn_t_lexcompare = 345
        hx_minsn_t_is_noret_call = 346
        hx_minsn_t_is_helper = 347
        hx_minsn_t_find_call = 348
        hx_minsn_t_has_side_effects = 349
        hx_minsn_t_find_opcode = 350
        hx_minsn_t_find_ins_op = 351
        hx_minsn_t_find_num_op = 352
        hx_minsn_t_modifies_d = 353
        hx_minsn_t_is_between = 354
        hx_minsn_t_may_use_aliased_memory = 355
        hx_minsn_t_serialize = 356
        hx_minsn_t_deserialize = 357
        hx_getf_reginsn = 358
        hx_getb_reginsn = 359
        hx_mblock_t_init = 360
        hx_mblock_t_print = 361
        hx_mblock_t_dump = 362
        hx_mblock_t_vdump_block = 363
        hx_mblock_t_insert_into_block = 364
        hx_mblock_t_remove_from_block = 365
        hx_mblock_t_for_all_insns = 366
        hx_mblock_t_for_all_ops = 367
        hx_mblock_t_for_all_uses = 368
        hx_mblock_t_optimize_insn = 369
        hx_mblock_t_optimize_block = 370
        hx_mblock_t_build_lists = 371
        hx_mblock_t_optimize_useless_jump = 372
        hx_mblock_t_append_use_list = 373
        hx_mblock_t_append_def_list = 374
        hx_mblock_t_build_use_list = 375
        hx_mblock_t_build_def_list = 376
        hx_mblock_t_find_first_use = 377
        hx_mblock_t_find_redefinition = 378
        hx_mblock_t_is_rhs_redefined = 379
        hx_mblock_t_find_access = 380
        hx_mblock_t_get_valranges = 381
        hx_mblock_t_get_valranges_ = 382
        hx_mblock_t_get_reginsn_qty = 383
        hx_mba_ranges_t_range_contains = 384
        hx_mba_t_stkoff_vd2ida = 385
        hx_mba_t_stkoff_ida2vd = 386
        hx_mba_t_idaloc2vd = 387
        hx_mba_t_idaloc2vd_ = 388
        hx_mba_t_vd2idaloc = 389
        hx_mba_t_vd2idaloc_ = 390
        hx_mba_t_term = 391
        hx_mba_t_get_curfunc = 392
        hx_mba_t_set_maturity = 393
        hx_mba_t_optimize_local = 394
        hx_mba_t_build_graph = 395
        hx_mba_t_get_graph = 396
        hx_mba_t_analyze_calls = 397
        hx_mba_t_optimize_global = 398
        hx_mba_t_alloc_lvars = 399
        hx_mba_t_dump = 400
        hx_mba_t_vdump_mba = 401
        hx_mba_t_print = 402
        hx_mba_t_verify = 403
        hx_mba_t_mark_chains_dirty = 404
        hx_mba_t_insert_block = 405
        hx_mba_t_remove_block = 406
        hx_mba_t_copy_block = 407
        hx_mba_t_remove_empty_and_unreachable_blocks = 408
        hx_mba_t_merge_blocks = 409
        hx_mba_t_for_all_ops = 410
        hx_mba_t_for_all_insns = 411
        hx_mba_t_for_all_topinsns = 412
        hx_mba_t_find_mop = 413
        hx_mba_t_create_helper_call = 414
        hx_mba_t_get_func_output_lists = 415
        hx_mba_t_arg = 416
        hx_mba_t_alloc_fict_ea = 417
        hx_mba_t_map_fict_ea = 418
        hx_mba_t_serialize = 419
        hx_mba_t_deserialize = 420
        hx_mba_t_save_snapshot = 421
        hx_mba_t_alloc_kreg = 422
        hx_mba_t_free_kreg = 423
        hx_mba_t_inline_func = 424
        hx_mba_t_locate_stkpnt = 425
        hx_mba_t_set_lvar_name = 426
        hx_mbl_graph_t_is_accessed_globally = 427
        hx_mbl_graph_t_get_ud = 428
        hx_mbl_graph_t_get_du = 429
        hx_cdg_insn_iterator_t_next = 430
        hx_codegen_t_clear = 431
        hx_codegen_t_emit = 432
        hx_codegen_t_emit_ = 433
        hx_change_hexrays_config = 434
        hx_get_hexrays_version = 435
        hx_open_pseudocode = 436
        hx_close_pseudocode = 437
        hx_get_widget_vdui = 438
        hx_decompile_many = 439
        hx_hexrays_failure_t_desc = 440
        hx_send_database = 441
        hx_gco_info_t_append_to_list = 442
        hx_get_current_operand = 443
        hx_remitem = 444
        hx_negated_relation = 445
        hx_swapped_relation = 446
        hx_get_op_signness = 447
        hx_asgop = 448
        hx_asgop_revert = 449
        hx_cnumber_t_print = 450
        hx_cnumber_t_value = 451
        hx_cnumber_t_assign = 452
        hx_cnumber_t_compare = 453
        hx_var_ref_t_compare = 454
        hx_ctree_visitor_t_apply_to = 455
        hx_ctree_visitor_t_apply_to_exprs = 456
        hx_ctree_parentee_t_recalc_parent_types = 457
        hx_cfunc_parentee_t_calc_rvalue_type = 458
        hx_citem_locator_t_compare = 459
        hx_citem_t_contains_expr = 460
        hx_citem_t_contains_label = 461
        hx_citem_t_find_parent_of = 462
        hx_citem_t_find_closest_addr = 463
        hx_cexpr_t_assign = 464
        hx_cexpr_t_compare = 465
        hx_cexpr_t_replace_by = 466
        hx_cexpr_t_cleanup = 467
        hx_cexpr_t_put_number = 468
        hx_cexpr_t_print1 = 469
        hx_cexpr_t_calc_type = 470
        hx_cexpr_t_equal_effect = 471
        hx_cexpr_t_is_child_of = 472
        hx_cexpr_t_contains_operator = 473
        hx_cexpr_t_get_high_nbit_bound = 474
        hx_cexpr_t_get_low_nbit_bound = 475
        hx_cexpr_t_requires_lvalue = 476
        hx_cexpr_t_has_side_effects = 477
        hx_cexpr_t_maybe_ptr = 478
        hx_cexpr_t_dstr = 479
        hx_cif_t_assign = 480
        hx_cif_t_compare = 481
        hx_cloop_t_assign = 482
        hx_cfor_t_compare = 483
        hx_cwhile_t_compare = 484
        hx_cdo_t_compare = 485
        hx_creturn_t_compare = 486
        hx_cthrow_t_compare = 487
        hx_cgoto_t_compare = 488
        hx_casm_t_compare = 489
        hx_cinsn_t_assign = 490
        hx_cinsn_t_compare = 491
        hx_cinsn_t_replace_by = 492
        hx_cinsn_t_cleanup = 493
        hx_cinsn_t_new_insn = 494
        hx_cinsn_t_create_if = 495
        hx_cinsn_t_print = 496
        hx_cinsn_t_print1 = 497
        hx_cinsn_t_is_ordinary_flow = 498
        hx_cinsn_t_contains_insn = 499
        hx_cinsn_t_collect_free_breaks = 500
        hx_cinsn_t_collect_free_continues = 501
        hx_cinsn_t_dstr = 502
        hx_cblock_t_compare = 503
        hx_carglist_t_compare = 504
        hx_ccase_t_compare = 505
        hx_ccases_t_compare = 506
        hx_cswitch_t_compare = 507
        hx_ccatch_t_compare = 508
        hx_ctry_t_compare = 509
        hx_ctree_item_t_get_udm = 510
        hx_ctree_item_t_get_edm = 511
        hx_ctree_item_t_get_lvar = 512
        hx_ctree_item_t_get_ea = 513
        hx_ctree_item_t_get_label_num = 514
        hx_ctree_item_t_print = 515
        hx_ctree_item_t_dstr = 516
        hx_lnot = 517
        hx_new_block = 518
        hx_vcreate_helper = 519
        hx_vcall_helper = 520
        hx_make_num = 521
        hx_make_ref = 522
        hx_dereference = 523
        hx_save_user_labels = 524
        hx_save_user_cmts = 525
        hx_save_user_numforms = 526
        hx_save_user_iflags = 527
        hx_save_user_unions = 528
        hx_restore_user_labels = 529
        hx_restore_user_cmts = 530
        hx_restore_user_numforms = 531
        hx_restore_user_iflags = 532
        hx_restore_user_unions = 533
        hx_cfunc_t_build_c_tree = 534
        hx_cfunc_t_verify = 535
        hx_cfunc_t_print_dcl = 536
        hx_cfunc_t_print_func = 537
        hx_cfunc_t_get_func_type = 538
        hx_cfunc_t_get_lvars = 539
        hx_cfunc_t_get_stkoff_delta = 540
        hx_cfunc_t_find_label = 541
        hx_cfunc_t_remove_unused_labels = 542
        hx_cfunc_t_get_user_cmt = 543
        hx_cfunc_t_set_user_cmt = 544
        hx_cfunc_t_get_user_iflags = 545
        hx_cfunc_t_set_user_iflags = 546
        hx_cfunc_t_has_orphan_cmts = 547
        hx_cfunc_t_del_orphan_cmts = 548
        hx_cfunc_t_get_user_union_selection = 549
        hx_cfunc_t_set_user_union_selection = 550
        hx_cfunc_t_save_user_labels = 551
        hx_cfunc_t_save_user_cmts = 552
        hx_cfunc_t_save_user_numforms = 553
        hx_cfunc_t_save_user_iflags = 554
        hx_cfunc_t_save_user_unions = 555
        hx_cfunc_t_get_line_item = 556
        hx_cfunc_t_get_warnings = 557
        hx_cfunc_t_get_eamap = 558
        hx_cfunc_t_get_boundaries = 559
        hx_cfunc_t_get_pseudocode = 560
        hx_cfunc_t_refresh_func_ctext = 561
        hx_cfunc_t_gather_derefs = 562
        hx_cfunc_t_find_item_coords = 563
        hx_cfunc_t_cleanup = 564
        hx_close_hexrays_waitbox = 565
        hx_decompile = 566
        hx_gen_microcode = 567
        hx_create_cfunc = 568
        hx_mark_cfunc_dirty = 569
        hx_clear_cached_cfuncs = 570
        hx_has_cached_cfunc = 571
        hx_get_ctype_name = 572
        hx_create_field_name = 573
        hx_install_hexrays_callback = 574
        hx_remove_hexrays_callback = 575
        hx_vdui_t_set_locked = 576
        hx_vdui_t_refresh_view = 577
        hx_vdui_t_refresh_ctext = 578
        hx_vdui_t_switch_to = 579
        hx_vdui_t_get_number = 580
        hx_vdui_t_get_current_label = 581
        hx_vdui_t_clear = 582
        hx_vdui_t_refresh_cpos = 583
        hx_vdui_t_get_current_item = 584
        hx_vdui_t_ui_rename_lvar = 585
        hx_vdui_t_rename_lvar = 586
        hx_vdui_t_ui_set_call_type = 587
        hx_vdui_t_ui_set_lvar_type = 588
        hx_vdui_t_set_lvar_type = 589
        hx_vdui_t_set_noptr_lvar = 590
        hx_vdui_t_ui_edit_lvar_cmt = 591
        hx_vdui_t_set_lvar_cmt = 592
        hx_vdui_t_ui_map_lvar = 593
        hx_vdui_t_ui_unmap_lvar = 594
        hx_vdui_t_map_lvar = 595
        hx_vdui_t_set_udm_type = 596
        hx_vdui_t_rename_udm = 597
        hx_vdui_t_set_global_type = 598
        hx_vdui_t_rename_global = 599
        hx_vdui_t_rename_label = 600
        hx_vdui_t_jump_enter = 601
        hx_vdui_t_ctree_to_disasm = 602
        hx_vdui_t_calc_cmt_type = 603
        hx_vdui_t_edit_cmt = 604
        hx_vdui_t_edit_func_cmt = 605
        hx_vdui_t_del_orphan_cmts = 606
        hx_vdui_t_set_num_radix = 607
        hx_vdui_t_set_num_enum = 608
        hx_vdui_t_set_num_stroff = 609
        hx_vdui_t_invert_sign = 610
        hx_vdui_t_invert_bits = 611
        hx_vdui_t_collapse_item = 612
        hx_vdui_t_collapse_lvars = 613
        hx_vdui_t_split_item = 614
        hx_select_udt_by_offset = 615
        hx_catchexpr_t_compare = 616
        hx_mba_t_split_block = 617
        hx_mba_t_remove_blocks = 618
        hx_cfunc_t_recalc_item_addresses = 619
        hx_int64_emulator_t_mop_value = 620
        hx_int64_emulator_t_minsn_value = 621
    cdef cppclass control_graph_t
    cdef cppclass edge_mapper_t
    cdef cppclass mba_stats_t
    cdef cppclass valrng_t:  # -------------------------------------------------------------------...
        valrng_t(int size_)
        valrng_t(const valrng_t & r)
        valrng_t & operator=(const valrng_t & r)
        void swap(valrng_t & r)
        bint operator==(const valrng_t & r) const
        bint operator!=(const valrng_t & r) const
        bint operator<(const valrng_t & r) const
        bint operator>(const valrng_t & r) const
        bint operator<=(const valrng_t & r) const
        bint operator>=(const valrng_t & r) const
        int compare(const valrng_t & r) const  # -------------------------------------------------------------------...
        void set_none()
        void set_all()
        void set_unk()
        void set_eq(uvlr_t v)  # -------------------------------------------------------------------...
        void set_cmp(cmpop_t cmp, uvlr_t _value)  # -------------------------------------------------------------------...
        bint reduce_size(int new_size)  # reduce size it takes the low part of size NEW_SIZE it returns "true...
        bint intersect_with(const valrng_t & r)  # Perform intersection or union or inversion.
        bint unite_with(const valrng_t & r)  # -------------------------------------------------------------------...
        void inverse()  # -------------------------------------------------------------------...
        bint empty() const
        bint all_values() const
        bint is_unknown() const
        bint has(uvlr_t v) const  # -------------------------------------------------------------------...
        const char * dstr() const  # -------------------------------------------------------------------...
        bint cvt_to_single_value(uvlr_t * v) const  # -------------------------------------------------------------------...
        bint cvt_to_cmp(cmpop_t * cmp, uvlr_t * val) const  # -------------------------------------------------------------------...
        int get_size() const
        uvlr_t max_value() const
        uvlr_t min_svalue() const
        uvlr_t max_svalue() const
    cdef cppclass ida_movable_type:
        pass
    cdef cppclass operand_locator_t:  # -------------------------------------------------------------------...
        ea_t ea  # address of the original processor instruction
        int opnum  # operand number in the instruction
        operand_locator_t(ea_t _ea, int _opnum)
        bint operator==(const operand_locator_t & r) const
        bint operator!=(const operand_locator_t & r) const
        bint operator<(const operand_locator_t & r) const
        bint operator>(const operand_locator_t & r) const
        bint operator<=(const operand_locator_t & r) const
        bint operator>=(const operand_locator_t & r) const
        int compare(const operand_locator_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass number_format_t:  # -------------------------------------------------------------------...
        flags_t flags32  # low 32bit of flags (for compatibility)
        char opnum  # operand number: 0..UA_MAXOP
        char props  # properties: combination of NF_ bits ( NF_)
        uchar serial  # for enums: constant serial number
        char org_nbytes  # original number size in bytes
        flags64_t flags  # ida flags, which describe number radix, enum, etc
        number_format_t(int _opnum)  # Contructor
        int get_radix() const  # Get number radix
        bint is_fixed() const  # Is number representation fixed? Fixed representation cannot be modi...
        bint is_hex() const  # Is a hexadecimal number?
        bint is_dec() const  # Is a decimal number?
        bint is_oct() const  # Is a octal number?
        bint is_enum() const  # Is a symbolic constant?
        bint is_char() const  # Is a character constant?
        bint is_stroff() const  # Is a structure field offset?
        bint is_numop() const  # Is a number?
        bint needs_to_be_inverted() const  # Does the number need to be negated or bitwise negated? Returns true...
        bint has_unmutable_type() const  # symbolic constants and struct offsets cannot easily change their si...
    cdef cppclass vd_printer_t:  # -------------------------------------------------------------------...
        int hdrlines  # number of header lines (prototype+typedef+lvars) valid at the end o...
        int print(int indent, const char * format)  # Print. This function is called to generate a portion of the output ...
    cdef cppclass vc_printer_t(vd_printer_t):  # Helper class to convert cfunc_t into text.
        const cfunc_t * func  # cfunc_t to generate text for
        char lastchar  # internal: last printed character
        vc_printer_t(const cfunc_t * f)  # Constructor
        bint oneliner() const  # Are we generating one-line text representation?
    cdef cppclass file_printer_t(vd_printer_t):  # Helper class to convert binary data structures into text and put in...
        FILE * fp  # Output file pointer
        int print(int indent, const char * format)  # Print. This function is called to generate a portion of the output ...
        file_printer_t(FILE * _fp)  # Constructor
    cdef cppclass qstring_printer_t(vc_printer_t):  # Helper class to convert cfunc_t into a text string
        bint with_tags  # Generate output with color tags
        int print(int indent, const char * format)  # Print. This function is called to generate a portion of the output ...
    cdef cppclass vdloc_t:  # -------------------------------------------------------------------...
        int reg1() const  # Get the register number. This function works only for ALOC_REG1 and...
        void _set_reg1(int r1)  # Set vdloc to point to the specified register without cleaning it up...
        void set_reg1(int r1)  # Set vdloc to point to the specified register.
        const char * dstr(int width) const  # Return textual representation. Note: this and all other dstr() func...
        bint operator==(const vdloc_t & r) const
        bint operator!=(const vdloc_t & r) const
        bint operator<(const vdloc_t & r) const
        bint operator>(const vdloc_t & r) const
        bint operator<=(const vdloc_t & r) const
        bint operator>=(const vdloc_t & r) const
        int compare(const vdloc_t & r) const  # -------------------------------------------------------------------...
        bint is_aliasable(const mba_t * mb, int size) const  # -------------------------------------------------------------------...
    cdef cppclass lvar_locator_t:  # Local variable locator. Local variables are located using definitio...
        vdloc_t location  # Variable location.
        ea_t defea  # Definition address. Usually, this is the address of the instruction...
        lvar_locator_t()
        lvar_locator_t(const vdloc_t & loc, ea_t ea)
        sval_t get_stkoff() const  # Get offset of the varialbe in the stack frame.
        bint is_reg1() const  # Is variable located on one register?
        bint is_reg2() const  # Is variable located on two registers?
        bint is_reg_var() const  # Is variable located on register(s)?
        bint is_stk_var() const  # Is variable located on the stack?
        bint is_scattered() const  # Is variable scattered?
        mreg_t get_reg1() const  # Get the register number of the variable
        mreg_t get_reg2() const  # Get the number of the second register (works only for ALOC_REG2 lvars)
        bint operator==(const lvar_locator_t & r) const
        bint operator!=(const lvar_locator_t & r) const
        bint operator<(const lvar_locator_t & r) const
        bint operator>(const lvar_locator_t & r) const
        bint operator<=(const lvar_locator_t & r) const
        bint operator>=(const lvar_locator_t & r) const
        int compare(const lvar_locator_t & r) const  # -------------------------------------------------------------------...
        const char * dstr() const  # Debugging: get textual representation of a lvar locator.
    cdef cppclass lvar_t(lvar_locator_t):  # Definition of a local variable (register or stack) #var #lvar
        int width  # variable size in bytes
        int defblk  # first block defining the variable. 0 for args, -1 if unknown
        uint64 divisor  # max known divisor of the variable
        lvar_t()
        const char * dstr() const  # Debugging: get textual representation of a local variable.
        bint used() const  # Is the variable used in the code?
        bint typed() const  # Has the variable a type?
        bint mreg_done() const  # Have corresponding microregs been replaced by references to this va...
        bint has_nice_name() const  # Does the variable have a nice name?
        bint is_unknown_width() const  # Do we know the width of the variable?
        bint has_user_info() const  # Has any user-defined information?
        bint has_user_name() const  # Has user-defined name?
        bint has_user_type() const  # Has user-defined type?
        bint is_result_var() const  # Is the function result?
        bint is_arg_var() const  # Is the function argument?
        bint is_promoted_arg() const  # Is the promoted function argument?
        bint is_fake_var() const  # Is fake return variable?
        bint is_overlapped_var() const  # Is overlapped variable?
        bint is_floating_var() const  # Used by a fpu insn?
        bint is_spoiled_var() const  # Is spoiled var? (meaningful only during lvar allocation)
        bint is_partialy_typed() const  # Variable type should be handled as a partial one
        bint is_noptr_var() const  # Variable type should not be a pointer
        bint is_mapdst_var() const  # Other variable(s) map to this var?
        bint is_thisarg() const  # Is 'this' argument of a C++ member function?
        bint is_split_var() const  # Is a split variable?
        bint has_regname() const  # Has a register name? (like _RAX)
        bint in_asm() const  # Is variable used in an instruction translated into __asm?
        bint is_dummy_arg() const  # Is a dummy argument (added to fill a hole in the argument list)
        bint is_notarg() const  # Is a local variable? (local variable cannot be an input argument)
        bint is_automapped() const  # Was the variable automatically mapped to another variable?
        bint is_used_byref() const  # Was the address of the variable taken?
        bint is_decl_unused() const  # Was declared as __unused by the user? See CVAR_UNUSED
        bint is_shared() const  # Is lvar mapped to several chains
        bint was_scattered_arg() const  # Was lvar transformed from a scattered argument?
        void set_used()
        void clear_used()
        void set_typed()
        void set_non_typed()
        void clr_user_info()
        void set_user_name()
        void set_user_type()
        void clr_user_type()
        void clr_user_name()
        void set_mreg_done()
        void clr_mreg_done()
        void set_unknown_width()
        void clr_unknown_width()
        void set_arg_var()
        void clr_arg_var()
        void set_fake_var()
        void clr_fake_var()
        void set_overlapped_var()
        void clr_overlapped_var()
        void set_floating_var()
        void clr_floating_var()
        void set_spoiled_var()
        void clr_spoiled_var()
        void set_mapdst_var()
        void clr_mapdst_var()
        void set_partialy_typed()
        void clr_partialy_typed()
        void set_noptr_var()
        void clr_noptr_var()
        void set_thisarg()
        void clr_thisarg()
        void set_split_var()
        void clr_split_var()
        void set_dummy_arg()
        void clr_dummy_arg()
        void set_notarg()
        void clr_notarg()
        void set_automapped()
        void clr_automapped()
        void set_used_byref()
        void clr_used_byref()
        void set_decl_unused()
        void clr_decl_unused()
        void set_shared()
        void clr_shared()
        void set_scattered_arg()
        void clr_scattered_arg()
        bint has_common(const lvar_t & v) const  # Do variables overlap?
        bint has_common_bit(const vdloc_t & loc, asize_t width2) const  # Does the variable overlap with the specified location?
        bint set_width(int w, int svw_flags)  # Change the variable width. We call the variable size 'width', it is...
        void append_list(const mba_t * mba, mlist_t * lst, bint pad_if_scattered) const  # Append local variable to mlist.
        bint is_aliasable(const mba_t * mba) const  # Is the variable aliasable?
    cdef cppclass lvars_t:  # Vector of local variables
        int find_input_lvar(const vdloc_t & argloc, int _size)  # Find an input variable at the specified location.
        int find_input_reg(int reg, int _size)  # Find an input register variable.
        int find_stkvar(sval_t spoff, int width)  # Find a stack variable at the specified location.
        lvar_t * find(const lvar_locator_t & ll)  # Find a variable at the specified location.
        int find_lvar(const vdloc_t & location, int width, int defblk) const  # Find a variable at the specified location.
    cdef cppclass lvar_saved_info_t:  # Saved user settings for local variables: name, type, comment.
        lvar_locator_t ll  # Variable locator
        ssize_t size  # Type size (if not initialized then -1)
        int flags  # LVINF_
        bint has_info() const  # @}
        bint operator==(const lvar_saved_info_t & r) const
        bint operator!=(const lvar_saved_info_t & r) const
        bint is_kept() const
        void clear_keep()
        void set_keep()
        bint is_split_lvar() const
        void set_split_lvar()
        void clr_split_lvar()
        bint is_noptr_lvar() const
        void set_noptr_lvar()
        void clr_noptr_lvar()
        bint is_nomap_lvar() const
        void set_nomap_lvar()
        void clr_nomap_lvar()
        bint is_unused_lvar() const
        void set_unused_lvar()
        void clr_unused_lvar()
    cdef cppclass lvar_uservec_t:  # All user-defined information about local variables
        lvar_mapping_t lmaps  # Local variable mapping (used for merging variables)
        uval_t stkoff_delta  # Delta to add to IDA stack offset to calculate Hex-Rays stack offset...
        int ulv_flags  # @} Various flags. Possible values are from ULV_
        void swap(lvar_uservec_t & r)
        void clear()
        bint empty() const
        lvar_saved_info_t * find_info(const lvar_locator_t & vloc)  # find saved user settings for given var
        void keep_info(const lvar_t & v)  # Preserve user settings for given var
    cdef cppclass user_lvar_modifier_t:  # Helper class to modify saved local variable settings.
        bint modify_lvars(lvar_uservec_t * lvinf)  # Modify lvar settings. Returns: true-modified
    cdef cppclass udcall_t:  # -------------------------------------------------------------------...
        bint operator==(const udcall_t & r) const
        bint operator!=(const udcall_t & r) const
        bint operator<(const udcall_t & r) const
        bint operator>(const udcall_t & r) const
        bint operator<=(const udcall_t & r) const
        bint operator>=(const udcall_t & r) const
        int compare(const udcall_t & r) const
        bint empty() const
    cdef cppclass microcode_filter_t:  # -------------------------------------------------------------------...
        bint match(codegen_t & cdg)  # check if the filter object is to be applied
        merror_t apply(codegen_t & cdg)  # generate microcode for an instruction
    cdef cppclass udc_filter_t(microcode_filter_t):  # -------------------------------------------------------------------...
        void cleanup()  # Cleanup the filter This function properly clears type information a...
        bint match(codegen_t & cdg)  # return true if the filter object should be applied to given instruc...
        bint init(const char * decl)  # -------------------------------------------------------------------...
        merror_t apply(codegen_t & cdg)  # -------------------------------------------------------------------...
        bint empty() const
    cdef cppclass bitset_t:  # Bit set class. See https://en.wikipedia.org/wiki/Bit_array
        bitset_t()
        bitset_t(const bitset_t & m)  # -------------------------------------------------------------------...
        void swap(bitset_t & r)
        bitset_t & operator=(const bitset_t & m)
        bitset_t & copy(const bitset_t & m)  # -------------------------------------------------------------------...
        bint add(int bit)  # -------------------------------------------------------------------...
        bint add(int bit, int width)  # -------------------------------------------------------------------...
        bint add(const bitset_t & ml)  # -------------------------------------------------------------------...
        bint sub(int bit)  # -------------------------------------------------------------------...
        bint sub(int bit, int width)  # -------------------------------------------------------------------...
        bint sub(const bitset_t & ml)  # -------------------------------------------------------------------...
        bint cut_at(int maxbit)  # -------------------------------------------------------------------...
        void shift_down(int shift)  # -------------------------------------------------------------------...
        bint has(int bit) const  # -------------------------------------------------------------------...
        bint has_all(int bit, int width) const  # -------------------------------------------------------------------...
        bint has_any(int bit, int width) const  # -------------------------------------------------------------------...
        const char * dstr() const  # -------------------------------------------------------------------...
        bint empty() const  # -------------------------------------------------------------------...
        int count() const  # -------------------------------------------------------------------...
        int count(int bit) const  # -------------------------------------------------------------------...
        int last() const  # -------------------------------------------------------------------...
        void clear()
        void fill_with_ones(int maxbit)  # -------------------------------------------------------------------...
        bint fill_gaps(int total_nbits)  # -------------------------------------------------------------------...
        bint has_common(const bitset_t & ml) const  # -------------------------------------------------------------------...
        bint intersect(const bitset_t & ml)  # -------------------------------------------------------------------...
        bint is_subset_of(const bitset_t & ml) const  # -------------------------------------------------------------------...
        bint includes(const bitset_t & ml) const
        bint operator==(const bitset_t & r) const
        bint operator!=(const bitset_t & r) const
        bint operator<(const bitset_t & r) const
        bint operator>(const bitset_t & r) const
        bint operator<=(const bitset_t & r) const
        bint operator>=(const bitset_t & r) const
        int compare(const bitset_t & r) const  # -------------------------------------------------------------------...
        int front() const
        int back() const
    cdef cppclass node_bitset_t(bitset_t):  # -------------------------------------------------------------------...
        node_bitset_t()
        node_bitset_t(int node)
    cdef cppclass array_of_node_bitset_t:
        pass
    cdef cppclass ivl_tpl[T]:
        pass
    cdef cppclass ivl_t:
        ivl_t(uval_t _off, uval_t _size)
        bint empty() const
        void clear()
        const char * dstr() const  # -------------------------------------------------------------------...
        bint extend_to_cover(const ivl_t & r)
        void intersect(const ivl_t & r)
        bint overlap(const ivl_t & ivl) const  # do *this and ivl overlap?
        bint includes(const ivl_t & ivl) const  # does *this include ivl?
        bint contains(uval_t off2) const  # does *this contain off2?
        bint operator==(const ivl_t & r) const
        bint operator!=(const ivl_t & r) const
        bint operator<(const ivl_t & r) const
        bint operator>(const ivl_t & r) const
        bint operator<=(const ivl_t & r) const
        bint operator>=(const ivl_t & r) const
        int compare(const ivl_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass ivl_with_name_t:  # -------------------------------------------------------------------...
        ivl_t ivl
        const char * whole  # name of the whole interval
        const char * part  # prefix to use for parts of the interval (e.g. sp+4)
        ivl_with_name_t()
    cdef cppclass ivlset_tpl[Ivl, T]:
        pass
    cdef cppclass ivlset_t:
        ivlset_t()
        ivlset_t(const ivl_t & ivl)
        bint add(const ivl_t & ivl)  # -------------------------------------------------------------------...
        bint add(ea_t ea, asize_t size)
        bint add(const ivlset_t & ivs)  # -------------------------------------------------------------------...
        bint addmasked(const ivlset_t & ivs, const ivl_t & mask)  # -------------------------------------------------------------------...
        bint sub(const ivl_t & ivl)  # -------------------------------------------------------------------...
        bint sub(ea_t ea, asize_t size)
        bint sub(const ivlset_t & ivs)  # -------------------------------------------------------------------...
        bint has_common(const ivl_t & ivl, bint strict) const  # -------------------------------------------------------------------...
        const char * dstr() const  # -------------------------------------------------------------------...
        asize_t count() const  # -------------------------------------------------------------------...
        bint has_common(const ivlset_t & ivs) const  # -------------------------------------------------------------------...
        bint contains(uval_t off) const  # -------------------------------------------------------------------...
        bint includes(const ivlset_t & ivs) const  # -------------------------------------------------------------------...
        bint intersect(const ivlset_t & ivs)  # -------------------------------------------------------------------...
        bint operator==(const ivlset_t & r) const
        bint operator!=(const ivlset_t & r) const
        bint operator<(const ivlset_t & r) const
        bint operator>(const ivlset_t & r) const
        bint operator<=(const ivlset_t & r) const
        bint operator>=(const ivlset_t & r) const
        int compare(const ivlset_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass rlist_t(bitset_t):  # -------------------------------------------------------------------...
        rlist_t()
        rlist_t(const rlist_t & m)
        rlist_t(mreg_t reg, int width)
        rlist_t & operator=(const rlist_t & arg22)
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass mlist_t:  # -------------------------------------------------------------------...
        rlist_t reg  # registers
        ivlset_t mem  # memory locations
        mlist_t()
        mlist_t(const ivl_t & ivl)
        mlist_t(mreg_t r, int size)
        void swap(mlist_t & r)
        bint addmem(ea_t ea, asize_t size)  # -------------------------------------------------------------------...
        bint add(mreg_t r, int size)
        bint add(const rlist_t & r)
        bint add(const ivl_t & ivl)
        bint add(const mlist_t & lst)
        bint sub(mreg_t r, int size)
        bint sub(const ivl_t & ivl)
        bint sub(const mlist_t & lst)
        asize_t count() const
        const char * dstr() const  # -------------------------------------------------------------------...
        bint empty() const
        void clear()
        bint has(mreg_t r) const
        bint has_all(mreg_t r, int size) const
        bint has_any(mreg_t r, int size) const
        bint has_memory() const
        bint has_allmem() const
        bint has_common(const mlist_t & lst) const
        bint includes(const mlist_t & lst) const
        bint intersect(const mlist_t & lst)
        bint is_subset_of(const mlist_t & lst) const
        bint operator==(const mlist_t & r) const
        bint operator!=(const mlist_t & r) const
        bint operator<(const mlist_t & r) const
        bint operator>(const mlist_t & r) const
        bint operator<=(const mlist_t & r) const
        bint operator>=(const mlist_t & r) const
        int compare(const mlist_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass optinsn_t:  # -------------------------------------------------------------------...
        int func(mblock_t * blk, minsn_t * ins, int optflags)  # Optimize an instruction.
    cdef cppclass optblock_t:  # User defined callback to optimize microcode blocks
        int func(mblock_t * blk)  # Optimize a block. This function usually performs the optimizations ...
    cdef cppclass simple_graph_t:  # -------------------------------------------------------------------...
        bint colored_gdl_edges
        bint ignore_edge(int arg28, int arg41) const  # this call is used to exclude edges in worklist_iterate... functions()
        void compute_dominators(array_of_node_bitset_t & domin, bint post) const  # -------------------------------------------------------------------...
        int front() const
        int goup(int node) const  # -------------------------------------------------------------------...
    cdef cppclass op_parent_info_t:  # The context info used by visitors
        mba_t * mba  # current microcode
        mblock_t * blk  # current block
        minsn_t * topins  # top level instruction (parent of curins or curins itself)
        minsn_t * curins  # currently visited instruction
        op_parent_info_t(mba_t * _mba, mblock_t * _blk, minsn_t * _topins)
        bint really_alloc() const
    cdef cppclass minsn_visitor_t(op_parent_info_t):  # Micro instruction visitor. See mba_t::for_all_topinsns, minsn_t::fo...
        minsn_visitor_t(mba_t * _mba, mblock_t * _blk, minsn_t * _topins)
        int visit_minsn()
    cdef cppclass mop_visitor_t(op_parent_info_t):  # Micro operand visitor. See mop_t::for_all_ops, minsn_t::for_all_ops...
        bint prune  # Should skip sub-operands of the current operand? visit_mop() may se...
        mop_visitor_t(mba_t * _mba, mblock_t * _blk, minsn_t * _topins)
    cdef cppclass scif_visitor_t:  # Scattered mop: visit each of the scattered locations as a separate ...
        int visit_scif_mop(const mop_t & r, int off)
    cdef cppclass mlist_mop_visitor_t:  # Used operand visitor. See mblock_t::for_all_uses
        minsn_t * topins
        minsn_t * curins
        bint changed
        mlist_t * list
        bint prune  # Should skip sub-operands of the current operand? visit_mop() may se...
        int visit_mop(mop_t * op)
    cdef cppclass lvar_ref_t:  # -------------------------------------------------------------------...
        mba_t *const mba  # Pointer to the parent mba_t object. Since we need to access the 'mb...
        sval_t off  # offset from the beginning of the variable
        int idx  # index into mba->vars
        lvar_ref_t(mba_t * m, int i, sval_t o)
        lvar_ref_t(const lvar_ref_t & r)
        lvar_ref_t & operator=(const lvar_ref_t & r)
        bint operator==(const lvar_ref_t & r) const
        bint operator!=(const lvar_ref_t & r) const
        bint operator<(const lvar_ref_t & r) const
        bint operator>(const lvar_ref_t & r) const
        bint operator<=(const lvar_ref_t & r) const
        bint operator>=(const lvar_ref_t & r) const
        int compare(const lvar_ref_t & r) const  # -------------------------------------------------------------------...
        void swap(lvar_ref_t & r)
        lvar_t & var() const  # -------------------------------------------------------------------...
    cdef cppclass stkvar_ref_t:  # -------------------------------------------------------------------...
        mba_t *const mba  # Pointer to the parent mba_t object. We need it in order to retrieve...
        sval_t off  # Offset to the stack variable from the bottom of the stack frame. It...
        stkvar_ref_t(mba_t * m, sval_t o)
        bint operator==(const stkvar_ref_t & r) const
        bint operator!=(const stkvar_ref_t & r) const
        bint operator<(const stkvar_ref_t & r) const
        bint operator>(const stkvar_ref_t & r) const
        bint operator<=(const stkvar_ref_t & r) const
        bint operator>=(const stkvar_ref_t & r) const
        int compare(const stkvar_ref_t & r) const  # -------------------------------------------------------------------...
        void swap(stkvar_ref_t & r)
    cdef cppclass scif_t(vdloc_t):  # -------------------------------------------------------------------...
        mba_t * mba  # Pointer to the parent mba_t object. Some operations may convert a s...
        scif_t & operator=(const vdloc_t & loc)
    cdef cppclass mnumber_t(operand_locator_t):  # -------------------------------------------------------------------...
        uint64 value
        uint64 org_value  # original value before changing the operand size
        mnumber_t(uint64 v, ea_t _ea, int n)
        bint operator==(const mnumber_t & r) const
        bint operator!=(const mnumber_t & r) const
        bint operator<(const mnumber_t & r) const
        bint operator>(const mnumber_t & r) const
        bint operator<=(const mnumber_t & r) const
        bint operator>=(const mnumber_t & r) const
        int compare(const mnumber_t & r) const
        void update_value(uint64 val64)  # always use this function instead of manually modifying the 'value' ...
    cdef cppclass fnumber_t:  # -------------------------------------------------------------------...
        int nbytes  # Original size of the constant in bytes
        const char * dstr() const  # -------------------------------------------------------------------...
        bint operator==(const fnumber_t & r) const
        bint operator!=(const fnumber_t & r) const
        bint operator<(const fnumber_t & r) const
        bint operator>(const fnumber_t & r) const
        bint operator<=(const fnumber_t & r) const
        bint operator>=(const fnumber_t & r) const
        int compare(const fnumber_t & r) const
        int calc_max_exp() const
        bint is_nan() const
    cdef cppclass mop_t:  # Microcode level forward definitions:
        mopt_t t  # Operand type.
        uint8 oprops  # Operand properties.
        uint16 valnum  # Value number. Zero means unknown. Operands with the same value numb...
        int size  # Operand size. Usually it is 1,2,4,8 or NOSIZE but for UDTs other si...
        mreg_t r  # mop_r register number
        mnumber_t * nnn  # mop_n immediate value
        minsn_t * d  # mop_d result (destination) of another instruction
        stkvar_ref_t * s  # mop_S stack variable
        ea_t g  # mop_v global variable (its linear address)
        int b  # mop_b block number (used in jmp,call instructions)
        mcallinfo_t * f  # mop_f function call information
        lvar_ref_t * l  # mop_l local variable
        mop_addr_t * a  # mop_a variable whose address is taken
        char * helper  # mop_h helper function name
        char * cstr  # mop_str utf8 string constant, user representation
        mcases_t * c  # mop_c cases
        fnumber_t * fpc  # mop_fn floating point constant
        mop_pair_t * pair  # mop_p operand pair
        scif_t * scif  # mop_sc scattered operand info
        void set_impptr_done()  # -- End of data fields, member function declarations follow:
        void set_udt()
        void set_undef_val()
        void set_lowaddr()
        void set_for_abi()
        bint is_impptr_done() const
        bint is_udt() const
        bint probably_floating() const
        bint is_undef_val() const
        bint is_lowaddr() const
        bint is_for_abi() const
        bint is_ccflags() const
        bint is_pcval() const
        bint is_glbaddr_from_fixup() const
        mop_t()
        mop_t(const mop_t & rop)
        mop_t(mreg_t _r, int _s)
        mop_t & operator=(const mop_t & rop)
        mop_t & assign(const mop_t & rop)  # -------------------------------------------------------------------...
        void zero()
        void swap(mop_t & rop)  # -------------------------------------------------------------------...
        void erase()  # -------------------------------------------------------------------...
        void erase_but_keep_size()
        const char * dstr() const  # -------------------------------------------------------------------...
        bint create_from_mlist(mba_t * mba, const mlist_t & lst, sval_t fullsize)  # -------------------------------------------------------------------...
        bint create_from_ivlset(mba_t * mba, const ivlset_t & ivs, sval_t fullsize)  # Create operand from ivlset_t. Example: if IVS contains [glbvar..glb...
        void create_from_vdloc(mba_t * mba, const vdloc_t & loc, int _size)  # Create operand from vdloc_t. Example: if LOC contains (type=ALOC_RE...
        void create_from_insn(const minsn_t * m)  # Create operand from an instruction. This function creates a nested ...
        void make_number(uint64 _value, int _size, ea_t _ea, int opnum)  # Create an integer constant operand.
        bint make_fpnum(const void * bytes, int _size)  # Create a floating point constant operand.
        void _make_reg(mreg_t reg)  # Create a register operand without erasing previous data.
        void _make_reg(mreg_t reg, int _size)
        void make_reg(mreg_t reg)  # Create a register operand.
        void make_reg(mreg_t reg, int _size)
        void _make_lvar(mba_t * mba, int idx, sval_t off)  # Create a local variable operand.
        void _make_gvar(ea_t ea)  # Create a global variable operand without erasing previous data.
        void make_gvar(ea_t ea)  # Create a global variable operand.
        void _make_stkvar(mba_t * mba, sval_t off)  # Create a stack variable operand.
        void make_stkvar(mba_t * mba, sval_t off)
        void make_reg_pair(int loreg, int hireg, int halfsize)  # Create pair of registers.
        void _make_insn(minsn_t * ins)  # Create a nested instruction without erasing previous data.
        void make_insn(minsn_t * ins)  # Create a nested instruction.
        void _make_blkref(int blknum)  # Create a block reference operand without erasing previous data.
        void make_blkref(int blknum)  # Create a global variable operand.
        void make_helper(const char * name)  # Create a helper operand. A helper operand usually keeps a built-in ...
        void _make_strlit(const char * str)  # Create a constant string operand.
        void _make_callinfo(mcallinfo_t * fi)  # Create a call info operand without erasing previous data.
        void _make_cases(mcases_t * _cases)  # Create a 'switch cases' operand without erasing previous data. Note...
        void _make_pair(mop_pair_t * _pair)  # Create a pair operand without erasing previous data. Note: this fun...
        bint empty() const  # -------------------------------------------------------------------...
        bint is_glbvar() const  # Is a global variable?
        bint is_stkvar() const  # Is a stack variable?
        bint is_reg() const  # Is a register operand? See also get_mreg_name()
        bint is_reg(mreg_t _r) const  # Is the specified register?
        bint is_reg(mreg_t _r, int _size) const  # Is the specified register of the specified size?
        bint is_arglist() const  # Is a list of arguments?
        bint is_cc() const  # Is a condition code?
        @staticmethod
        bint is_bit_reg(mreg_t reg)  # Is a bit register? This includes condition codes and eventually oth...
        bint is_bit_reg() const
        bint is_kreg() const  # Is a kernel register?
        bint is_mblock() const  # Is a block reference?
        bint is_mblock(int serial) const  # Is a block reference to the specified block?
        bint is_scattered() const  # Is a scattered operand?
        bint is_glbaddr() const  # Is address of a global memory cell?
        bint is_glbaddr(ea_t ea) const  # Is address of the specified global memory cell?
        bint is_stkaddr() const  # Is address of a stack variable?
        bint is_insn() const  # Is a sub-instruction?
        bint is_insn(mcode_t code) const  # Is a sub-instruction with the specified opcode?
        bint has_side_effects(bint include_ldx_and_divs) const  # Has any side effects?
        bint may_use_aliased_memory() const  # Is it possible for the operand to use aliased memory?
        bint is01() const  # Are the possible values of the operand only 0 and 1? This function ...
        bint is_sign_extended_from(int nbytes) const  # Does the high part of the operand consist of the sign bytes?
        bint is_zero_extended_from(int nbytes) const  # Does the high part of the operand consist of zero bytes?
        bint is_extended_from(int nbytes, bint is_signed) const  # Does the high part of the operand consist of zero or sign bytes?
        bint equal_mops(const mop_t & rop, int eqflags) const  # -------------------------------------------------------------------...
        bint operator==(const mop_t & rop) const
        bint operator!=(const mop_t & rop) const
        bint operator<(const mop_t & rop) const  # Lexographical operand comparison. It can be used to store mop_t in ...
        int lexcompare(const mop_t & rop) const  # -------------------------------------------------------------------...
        int for_all_scattered_submops(scif_visitor_t & sv) const  # Visit all sub-operands of a scattered operand. This function does n...
        uint64 value(bint is_signed) const  # -------------------------------------------------------------------...
        int64 signed_value() const
        uint64 unsigned_value() const
        void update_numop_value(uint64 val)
        bint is_constant(uint64 * out, bint is_signed) const  # Retrieve value of a constant integer operand.
        bint is_equal_to(uint64 n, bint is_signed) const
        bint is_zero() const
        bint is_one() const
        bint is_positive_constant() const
        bint is_negative_constant() const
        bint get_stkoff(sval_t * p_vdoff) const  # Get the referenced stack offset. This function can also handle mop_...
        const minsn_t * get_insn(mcode_t code) const  # -------------------------------------------------------------------...
        minsn_t * get_insn(mcode_t code)
        bint make_low_half(int width)  # -------------------------------------------------------------------...
        bint make_high_half(int width)  # Make the high part of the operand. This function takes into account...
        bint make_first_half(int width)  # Make the first part of the operand. This function does not care abo...
        bint make_second_half(int width)  # Make the second part of the operand. This function does not care ab...
        bint shift_mop(int offset)  # Shift the operand. This function shifts only the beginning of the o...
        bint change_size(int nsize, side_effect_t sideff)  # Change the operand size. Examples: change_size(AL.1, 2) -> AX.2 cha...
        bint double_size(side_effect_t sideff)
        bint preserve_side_effects(mblock_t * blk, minsn_t * top, bint * moved_calls)  # Move subinstructions with side effects out of the operand. If we de...
        void apply_ld_mcode(mcode_t mcode, ea_t ea, int newsize)  # Apply a unary opcode to the operand.
        void apply_xdu(ea_t ea, int newsize)
        void apply_xds(ea_t ea, int newsize)
    cdef cppclass mop_pair_t:  # Pair of operands
        mop_t lop  # low operand
        mop_t hop  # high operand
    cdef cppclass mop_addr_t(mop_t):  # Address of an operand (mop_l, mop_v, mop_S, mop_r)
        int insize  # how many bytes of the pointed operand can be read
        int outsize  # how many bytes of the pointed operand can be written
        mop_addr_t()
        mop_addr_t(const mop_addr_t & ra)
        mop_addr_t(const mop_t & ra, int isz, int osz)
        mop_addr_t & operator=(const mop_addr_t & rop)
        int lexcompare(const mop_addr_t & ra) const
    cdef cppclass mcallarg_t(mop_t):  # A call argument
        ea_t ea  # address where the argument was initialized. BADADDR means unknown.
        uint32 flags  # FAI_...
        mcallarg_t()
        mcallarg_t(const mop_t & rarg)
        void copy_mop(const mop_t & op)
        const char * dstr() const  # -------------------------------------------------------------------...
        void make_int(int val, ea_t val_ea, int opno)
        void make_uint(int val, ea_t val_ea, int opno)
    cdef cppclass mcallinfo_t:  # Information about a call
        ea_t callee  # address of the called function, if known
        int solid_args  # number of solid args. there may be variadic args in addtion
        int call_spd  # sp value at call insn
        int stkargs_top  # first offset past stack arguments
        mlist_t return_regs  # list of values returned by the function
        mlist_t spoiled  # list of spoiled locations (includes return_regs)
        mlist_t pass_regs  # passthrough registers: registers that depend on input values (subse...
        ivlset_t visible_memory  # what memory is visible to the call?
        mlist_t dead_regs  # registers defined by the function but never used. upon propagation ...
        int flags  # combination of FCI_... bits
        funcrole_t role  # function role
        mcallinfo_t(ea_t _callee, int _sargs)
        int lexcompare(const mcallinfo_t & f) const  # -------------------------------------------------------------------...
        bint is_vararg() const
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass mcases_t:  # List of switch cases and targets
        void swap(mcases_t & r)
        bint operator==(const mcases_t & r) const
        bint operator!=(const mcases_t & r) const
        bint operator<(const mcases_t & r) const
        bint operator>(const mcases_t & r) const
        bint operator<=(const mcases_t & r) const
        bint operator>=(const mcases_t & r) const
        int compare(const mcases_t & r) const  # -------------------------------------------------------------------...
        bint empty() const
        int size() const
        void resize(int s)
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass voff_t:  # -------------------------------------------------------------------...
        sval_t off  # register number or stack offset
        mopt_t type  # mop_r - register, mop_S - stack, mop_z - undefined
        voff_t()
        voff_t(mopt_t _type, sval_t _off)
        voff_t(const mop_t & op)
        void set(mopt_t _type, sval_t _off)
        void set_stkoff(sval_t stkoff)
        void set_reg(mreg_t mreg)
        void undef()
        bint defined() const
        bint is_reg() const
        bint is_stkoff() const
        mreg_t get_reg() const
        sval_t get_stkoff() const
        void inc(sval_t delta)
        voff_t add(int width) const
        sval_t diff(const voff_t & r) const
        bint operator==(const voff_t & r) const
        bint operator!=(const voff_t & r) const
        bint operator<(const voff_t & r) const
        bint operator>(const voff_t & r) const
        bint operator<=(const voff_t & r) const
        bint operator>=(const voff_t & r) const
        int compare(const voff_t & r) const
    cdef cppclass vivl_t(voff_t):  # -------------------------------------------------------------------...
        int size  # Interval size in bytes
        vivl_t(mopt_t _type, sval_t _off, int _size)
        vivl_t(const chain_t & ch)
        vivl_t(const mop_t & op)
        void set(mopt_t _type, sval_t _off, int _size)  # Make a value interval
        void set(const voff_t & voff, int _size)
        void set_stkoff(sval_t stkoff, int sz)
        void set_reg(mreg_t mreg, int sz)
        bint extend_to_cover(const vivl_t & r)  # Extend a value interval using another value interval of the same type
        uval_t intersect(const vivl_t & r)  # Intersect value intervals the same type
        bint overlap(const vivl_t & r) const  # Do two value intervals overlap?
        bint includes(const vivl_t & r) const  # Does our value interval include another?
        bint contains(const voff_t & voff2) const  # Does our value interval contain the specified value offset?
        bint operator==(const vivl_t & r) const  # Comparisons
        bint operator!=(const vivl_t & r) const  # Comparisons
        bint operator<(const vivl_t & r) const  # Comparisons
        bint operator>(const vivl_t & r) const  # Comparisons
        bint operator<=(const vivl_t & r) const  # Comparisons
        bint operator>=(const vivl_t & r) const  # Comparisons
        int compare(const vivl_t & r) const  # Comparisons
        bint operator==(const mop_t & mop) const
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass chain_t:  # -------------------------------------------------------------------...
        int width  # size of the value in bytes
        int varnum  # allocated variable index (-1 - not allocated yet)
        uchar flags  # combination CHF_ bits
        chain_t()  # @}
        chain_t(mopt_t t, sval_t off, int w, int v)
        chain_t(const voff_t & _k, int w)
        void set_value(const chain_t & r)
        const voff_t & key() const
        bint is_inited() const
        bint is_reg() const
        bint is_stkoff() const
        bint is_replaced() const
        bint is_overlapped() const
        bint is_fake() const
        bint is_passreg() const
        bint is_term() const
        void set_inited(bint b)
        void set_replaced(bint b)
        void set_overlapped(bint b)
        void set_term(bint b)
        mreg_t get_reg() const
        sval_t get_stkoff() const
        bint overlap(const chain_t & r) const
        bint includes(const chain_t & r) const
        const voff_t endoff() const
        bint operator<(const chain_t & r) const
        const char * dstr() const  # -------------------------------------------------------------------...
        void append_list(const mba_t * mba, mlist_t * list) const  # Append the contents of the chain to the specified list of locations.
        void clear_varnum()
    cdef cppclass block_chains_t:  # Chains of one block. Please note that this class is based on std::s...
        const chain_t * get_reg_chain(mreg_t reg, int width) const  # Get chain for the specified register
        chain_t * get_reg_chain(mreg_t reg, int width)
        const chain_t * get_stk_chain(sval_t off, int width) const  # Get chain for the specified stack offset
        chain_t * get_stk_chain(sval_t off, int width)
        const chain_t * get_chain(const voff_t & k, int width) const  # Get chain for the specified value offset.
        chain_t * get_chain(const voff_t & k, int width)
        const chain_t * get_chain(const chain_t & ch) const  # Get chain similar to the specified chain
        chain_t * get_chain(const chain_t & ch)
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass chain_visitor_t:  # -------------------------------------------------------------------...
        block_chains_t * parent  # parent of the current chain
        int visit_chain(int nblock, chain_t & ch)
    cdef cppclass graph_chains_t:
        int for_all_chains(chain_visitor_t & cv, int gca_flags)  # Visit all chains
        bint is_locked() const  # @} Are the chains locked? It is a good idea to lock the chains befo...
        void acquire()  # Lock the chains
        void release()  # Unlock the chains
        void swap(graph_chains_t & r)
    cdef cppclass minsn_t:  # -------------------------------------------------------------------...
        mcode_t opcode  # instruction opcode
        int iprops  # combination of IPROP_ bits
        minsn_t * next  # next insn in doubly linked list. check also nexti()
        minsn_t * prev  # prev insn in doubly linked list. check also previ()
        ea_t ea  # instruction address
        mop_t l  # left operand
        mop_t r  # right operand
        mop_t d  # destination operand
        bint is_optional() const  # @}
        bint is_combined() const
        bint is_farcall() const
        bint is_cleaning_pop() const
        bint is_extstx() const
        bint is_tailcall() const
        bint is_fpinsn() const
        bint is_assert() const
        bint is_persistent() const
        bint is_wild_match() const
        bint is_propagatable() const
        bint is_ignlowsrc() const
        bint is_inverted_jx() const
        bint was_noret_icall() const
        bint is_multimov() const
        bint is_combinable() const
        bint was_split() const
        bint is_mbarrier() const
        bint was_unmerged() const
        bint was_unpaired() const
        void set_optional()
        void set_combined()  # -------------------------------------------------------------------...
        void clr_combined()
        void set_farcall()
        void set_cleaning_pop()
        void set_extstx()
        void set_tailcall()
        void clr_tailcall()
        void set_fpinsn()
        void clr_fpinsn()
        void set_assert()
        void clr_assert()
        void set_persistent()
        void set_wild_match()
        void clr_propagatable()
        void set_ignlowsrc()
        void clr_ignlowsrc()
        void set_inverted_jx()
        void set_noret_icall()
        void clr_noret_icall()
        void set_multimov()
        void clr_multimov()
        void set_combinable()
        void clr_combinable()
        void set_mbarrier()
        void set_unmerged()
        void set_split_size(int s)
        int get_split_size() const
        minsn_t(ea_t _ea)  # Constructor
        minsn_t(const minsn_t & m)
        minsn_t & operator=(const minsn_t & m)  # Assignment operator. It does not copy prev/next fields.
        void swap(minsn_t & m)  # Swap two instructions. The prev/next fields are not modified by thi...
        const char * dstr() const  # Get displayable text without tags in a static buffer
        void setaddr(ea_t new_ea)  # Change the instruction address. This function modifies subinstructi...
        int optimize_solo(int optflags)  # Optimize one instruction without context. This function does not ha...
        int optimize_subtree(mblock_t * blk, minsn_t * top, minsn_t * parent, ea_t * converted_call, int optflags)  # Optimize instruction in its context. Do not use this function, use ...
        int for_all_ops(mop_visitor_t & mv)  # Visit all instruction operands. This function visits subinstruction...
        int for_all_insns(minsn_visitor_t & mv)  # Visit all instructions. This function visits the instruction itself...
        void _make_nop()  # Convert instruction to nop. This function erases all info but the p...
        bint equal_insns(const minsn_t & m, int eqflags) const  # Compare instructions. This is the main comparison function for inst...
        bint operator<(const minsn_t & ri) const  # Lexographical comparison It can be used to store minsn_t in various...
        int lexcompare(const minsn_t & ri) const  # -------------------------------------------------------------------...
        bint is_noret_call(int flags)  # -------------------------------------------------------------------...
        bint is_unknown_call() const  # Is an unknown call? Unknown calls are calls without the argument li...
        bint is_helper(const char * name) const  # Is a helper call with the specified name? Helper calls usually have...
        minsn_t * find_call(bint with_helpers) const  # Find a call instruction. Check for the current instruction and its ...
        bint contains_call(bint with_helpers) const  # Does the instruction contain a call?
        bint has_side_effects(bint include_ldx_and_divs) const  # Does the instruction have a side effect?
        funcrole_t get_role() const  # Get the function role of a call
        bint is_memcpy() const
        bint is_memset() const
        bint is_alloca() const
        bint is_bswap() const
        bint is_readflags() const
        bint contains_opcode(mcode_t mcode) const  # -------------------------------------------------------------------...
        const minsn_t * find_opcode(mcode_t mcode) const  # Find a (sub)insruction with the specified opcode.
        minsn_t * find_opcode(mcode_t mcode)  # -------------------------------------------------------------------...
        const minsn_t * find_ins_op(const mop_t ** other, mcode_t op) const  # Find an operand that is a subinsruction with the specified opcode. ...
        minsn_t * find_ins_op(mop_t ** other, mcode_t op)
        const mop_t * find_num_op(const mop_t ** other) const  # Find a numeric operand of the current instruction. This function ch...
        mop_t * find_num_op(mop_t ** other)
        bint is_mov() const
        bint is_like_move() const
        bint modifies_d() const  # Does the instruction modify its 'd' operand? Some instructions (e.g...
        bint modifies_pair_mop() const
        bint is_between(const minsn_t * m1, const minsn_t * m2) const  # Is the instruction in the specified range of instructions?
        bint is_after(const minsn_t * m) const  # Is the instruction after the specified one?
        bint may_use_aliased_memory() const  # Is it possible for the instruction to use aliased memory?
        bint deserialize(const uchar * bytes, int nbytes, int format_version)  # Deserialize an instruction
    cdef cppclass intval64_t:  # -------------------------------------------------------------------...
        uint64 val
        int size  # in bytes
        intval64_t(uint64 v, int _s)
        int64 sval() const
        uint64 uval() const
        bint operator==(const intval64_t & o) const  # -------------------------------------------------------------------...
        bint operator!=(const intval64_t & o) const  # -------------------------------------------------------------------...
        bint operator<(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t sext(int target_sz) const  # -------------------------------------------------------------------...
        intval64_t zext(int target_sz) const  # -------------------------------------------------------------------...
        intval64_t low(int target_sz) const  # -------------------------------------------------------------------...
        intval64_t high(int target_sz) const  # -------------------------------------------------------------------...
        intval64_t operator+(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator-(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator*(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator/(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t sdiv(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator%(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t smod(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator<<(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator>>(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t sar(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator|(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator&(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator^(const intval64_t & o) const  # -------------------------------------------------------------------...
        intval64_t operator-() const  # -------------------------------------------------------------------...
        intval64_t operator!() const  # -------------------------------------------------------------------...
        intval64_t operator~() const  # -------------------------------------------------------------------...
    cdef cppclass int64_emulator_t:  # -------------------------------------------------------------------...
        intval64_t get_mop_value(const mop_t & mop)  # Retreive the value assigned to an operand. This function is called ...
        intval64_t mop_value(const mop_t & mop)  # Calculate the operand value. For register/stack/memory/lvar operand...
        intval64_t minsn_value(const minsn_t & insn)  # Calculate the result of applying the instruction opcode to its sour...
    cdef cppclass mblock_t:  # -------------------------------------------------------------------...
        mblock_t * nextb  # next block in the doubly linked list
        mblock_t * prevb  # previous block in the doubly linked list
        uint32 flags  # combination of MBL_ bits
        ea_t start  # start address
        ea_t end  # end address note: we cannot rely on start/end addresses very much b...
        minsn_t * head  # pointer to the first instruction of the block
        minsn_t * tail  # pointer to the last instruction of the block
        mba_t * mba  # the parent micro block array
        int serial  # block number
        mblock_type_t type  # block type (BLT_NONE - not computed yet)
        mlist_t dead_at_start  # data that is dead at the block entry
        mlist_t mustbuse  # data that must be used by the block
        mlist_t maybuse  # data that may be used by the block
        mlist_t mustbdef  # data that must be defined by the block
        mlist_t maybdef  # data that may be defined by the block
        mlist_t dnu  # data that is defined but not used in the block
        sval_t maxbsp  # maximal sp value in the block (0...stacksize)
        sval_t minbstkref  # lowest stack location accessible with indirect addressing (offset f...
        sval_t minbargref  # the same for arguments
        void mark_lists_dirty()
        void request_propagation()
        bint needs_propagation() const
        void request_demote64()
        bint lists_dirty() const
        bint lists_ready() const
        int make_lists_ready()
        int npred() const  # Get number of block predecessors
        int nsucc() const  # Get number of block successors
        int pred(int n) const  # Get predecessor number N
        int succ(int n) const  # Get successor number N
        mblock_t()
        bint empty() const
        void print(vd_printer_t & vp) const  # Print block contents.
        void dump() const  # Dump block info. This function is useful for debugging, see mba_t::...
        void dump_block(const char * title) const
        minsn_t * insert_into_block(minsn_t * nm, minsn_t * om)  # -------------------------------------------------------------------...
        minsn_t * remove_from_block(minsn_t * m)  # Remove instruction from the doubly linked list
        int for_all_insns(minsn_visitor_t & mv)  # -------------------------------------------------------------------...
        int for_all_ops(mop_visitor_t & mv)  # Visit all operands. This function visit subinstruction operands too.
        int for_all_uses(mlist_t * list, minsn_t * i1, minsn_t * i2, mlist_mop_visitor_t & mmv)  # Visit all operands that use LIST.
        int optimize_insn(minsn_t * m, int optflags)  # -------------------------------------------------------------------...
        int optimize_block()  # Optimize a basic block. Usually there is no need to call this funct...
        int build_lists(bint kill_deads)  # Build def-use lists and eliminate deads.
        int optimize_useless_jump()  # Remove a jump at the end of the block if it is useless. This functi...
        void append_def_list(mlist_t * list, const mop_t & op, maymust_t maymust) const  # Append def-list of an operand. This function calculates list of loc...
        mlist_t build_use_list(const minsn_t & ins, maymust_t maymust) const  # Build use-list of an instruction. This function calculates list of ...
        mlist_t build_def_list(const minsn_t & ins, maymust_t maymust) const  # Build def-list of an instruction. This function calculates list of ...
        bint is_used(mlist_t * list, const minsn_t * i1, const minsn_t * i2, maymust_t maymust) const  # -------------------------------------------------------------------...
        const minsn_t * find_first_use(mlist_t * list, const minsn_t * i1, const minsn_t * i2, maymust_t maymust) const  # Find the first insn that uses the specified list in the insn range.
        minsn_t * find_first_use(mlist_t * list, minsn_t * i1, const minsn_t * i2, maymust_t maymust) const
        bint is_redefined(const mlist_t & list, const minsn_t * i1, const minsn_t * i2, maymust_t maymust) const  # Is the list redefined by the specified instructions?
        const minsn_t * find_redefinition(const mlist_t & list, const minsn_t * i1, const minsn_t * i2, maymust_t maymust) const  # Find the first insn that redefines any part of the list in the insn...
        minsn_t * find_redefinition(const mlist_t & list, minsn_t * i1, const minsn_t * i2, maymust_t maymust) const
        bint is_rhs_redefined(const minsn_t * ins, const minsn_t * i1, const minsn_t * i2) const  # Is the right hand side of the instruction redefined the insn range?...
        minsn_t * find_access(const mop_t & op, minsn_t ** parent, const minsn_t * mend, int fdflags) const  # Find the instruction that accesses the specified operand. This func...
        minsn_t * find_def(const mop_t & op, minsn_t ** p_i1, const minsn_t * i2, int fdflags)  # Convenience functions:
        minsn_t * find_use(const mop_t & op, minsn_t ** p_i1, const minsn_t * i2, int fdflags)
        bint get_valranges(valrng_t * res, const vivl_t & vivl, int vrflags) const  # Find possible values for a block.
        bint get_valranges(valrng_t * res, const vivl_t & vivl, const minsn_t * m, int vrflags) const  # Find possible values for an instruction.
        void make_nop(minsn_t * m)  # Erase the instruction (convert it to nop) and mark the lists dirty....
        int get_reginsn_qty() const  # Calculate number of regular instructions in the block. Assertions a...
        bint is_call_block() const
        bint is_unknown_call() const
        bint is_nway() const
        bint is_branch() const
        bint is_simple_goto_block() const
        bint is_simple_jcnd_block() const
    cdef cppclass hexwarn_t:  # Warning instances
        ea_t ea  # Address where the warning occurred
        warnid_t id  # Warning id
        bint operator==(const hexwarn_t & r) const
        bint operator!=(const hexwarn_t & r) const
        bint operator<(const hexwarn_t & r) const
        bint operator>(const hexwarn_t & r) const
        bint operator<=(const hexwarn_t & r) const
        bint operator>=(const hexwarn_t & r) const
        int compare(const hexwarn_t & r) const
    cdef cppclass mba_ranges_t:  # -------------------------------------------------------------------...
        ea_t start() const
        bint empty() const
        void clear()
        bint is_snippet() const
        bint range_contains(ea_t ea) const  # -------------------------------------------------------------------...
        bint is_fragmented() const
    cdef cppclass range_item_iterator_t:  # Item iterator of arbitrary rangevec items
        ea_t cur  # current address
        bint next_code()
        ea_t current() const
    cdef cppclass mba_item_iterator_t:  # Item iterator for mba_ranges_t
        bint func_items_done
        bint set(const mba_ranges_t & mbr)
        bint next_code()
        ea_t current() const
    cdef cppclass range_chunk_iterator_t:  # Chunk iterator of arbitrary rangevec items
        bint next()
    cdef cppclass mba_range_iterator_t:  # Chunk iterator for mba_ranges_t
        bint is_snippet() const
        bint set(const mba_ranges_t & mbr)
        bint next()
    cdef cppclass mba_t:  # -------------------------------------------------------------------...
        mba_ranges_t mbr
        ea_t entry_ea
        ea_t last_prolog_ea
        ea_t first_epilog_ea
        int qty  # number of basic blocks
        int npurged  # -1 - unknown
        sval_t tmpstk_size  # size of the temporary stack part (which dynamically changes with pu...
        sval_t frsize  # size of local stkvars range in the stack frame
        sval_t frregs  # size of saved registers range in the stack frame
        sval_t fpd  # frame pointer delta
        int pfn_flags  # copy of func_t::flags
        int retsize  # size of return address in the stack frame
        int shadow_args  # size of shadow argument area
        sval_t fullsize  # Full stack size including incoming args
        sval_t stacksize  # The maximal size of the function stack including bytes allocated fo...
        sval_t inargoff  # offset of the first stack argument; after fix_scattered_movs() INAR...
        sval_t minstkref  # The lowest stack location whose address was taken
        ea_t minstkref_ea  # address with lowest minstkref (for debugging)
        sval_t minargref  # The lowest stack argument location whose address was taken This loc...
        sval_t spd_adjust  # If sp>0, the max positive sp value
        ivlset_t gotoff_stkvars  # stkvars that hold .got offsets. considered to be unaliasable
        ivlset_t restricted_memory
        ivlset_t aliased_memory  # aliased_memory+restricted_memory=ALLMEM
        mlist_t nodel_memory  # global dead elimination may not delete references to this area
        rlist_t consumed_argregs  # registers converted into stack arguments, should not be used as arg...
        mba_maturity_t maturity  # current maturity level
        mba_maturity_t reqmat  # required maturity level
        bint final_type  # is the function type final? (specified by the user)
        mlist_t spoiled_list  # MBA_SPLINFO && !final_type: info in vd format
        int fti_flags  # FTI_... constants for the current function
        lvars_t vars  # local variables
        int retvaridx  # index of variable holding the return value -1 means none
        ea_t error_ea  # during microcode generation holds ins.ea
        mblock_t * blocks  # double linked list of blocks
        mblock_t ** natural  # natural order of blocks
        bint precise_defeas() const
        bint optimized() const
        bint short_display() const
        bint show_reduction() const
        bint graph_insns() const
        bint loaded_gdl() const
        bint should_beautify() const
        bint rtype_refined() const
        bint may_refine_rettype() const
        bint use_wingraph32() const
        bint display_numaddrs() const
        bint display_valnums() const
        bint is_pattern() const
        bint is_thunk() const
        bint saverest_done() const
        bint callinfo_built() const
        bint really_alloc() const
        bint lvars_allocated() const
        bint chain_varnums_ok() const
        bint returns_fpval() const
        bint has_passregs() const
        bint generated_asserts() const
        bint propagated_asserts() const
        bint deleted_pairs() const
        bint common_stkvars_stkargs() const
        bint lvar_names_ok() const
        bint lvars_renamed() const
        bint has_over_chains() const
        bint valranges_done() const
        bint argidx_ok() const
        bint argidx_sorted() const
        bint code16_bit_removed() const
        bint has_stack_retval() const
        bint has_outlines() const
        bint is_ctr() const
        bint is_dtr() const
        bint is_cdtr() const
        bint prop_complex() const
        int get_mba_flags() const
        int get_mba_flags2() const
        void set_mba_flags(int f)
        void clr_mba_flags(int f)
        void set_mba_flags2(int f)
        void clr_mba_flags2(int f)
        void clr_cdtr()
        int calc_shins_flags() const
        sval_t stkoff_vd2ida(sval_t off) const  # convert a stack offset used in vd to a stack offset used in ida sta...
        sval_t stkoff_ida2vd(sval_t off) const  # convert a ida stack frame offset to a stack offset used in vd
        sval_t argbase() const
        bint is_stkarg(const lvar_t & v) const
        bint write_to_const_detected() const
        bint bad_call_sp_detected() const
        bint regargs_is_not_aligned() const
        bint has_bad_sp() const
        mba_t()
        void term()  # -------------------------------------------------------------------...
        bint use_frame() const
        bint range_contains(ea_t ea) const
        bint is_snippet() const
        merror_t set_maturity(mba_maturity_t mat)  # Set maturity level.
        int optimize_local(int locopt_bits)  # Optimize each basic block locally
        merror_t build_graph()  # Build control flow graph. This function may be called only once. It...
        mbl_graph_t * get_graph()  # Get control graph. Call build_graph() if you need the graph before ...
        int analyze_calls(int acflags)  # Analyze calls and determine calling conventions.
        merror_t optimize_global()  # Optimize microcode globally. This function applies various optimiza...
        void alloc_lvars()  # Allocate local variables. Must be called only immediately after opt...
        void dump() const  # Dump microcode to a file. The file will be created in the directory...
        void dump_mba(bint _verify, const char * title) const
        void print(vd_printer_t & vp) const  # Print microcode to any destination.
        void verify(bint always) const  # Verify microcode consistency.
        void mark_chains_dirty()  # Mark the microcode use-def chains dirty. Call this function is any ...
        const mblock_t * get_mblock(uint n) const  # Get basic block by its serial number.
        mblock_t * get_mblock(uint n)
        mblock_t * insert_block(int bblk)  # Insert a block in the middle of the mbl array. The very first block...
        mblock_t * split_block(mblock_t * blk, minsn_t * start_insn)  # Split a block: insert a new one after the block, move some instruct...
        bint remove_block(mblock_t * blk)  # Delete a block.
        bint remove_blocks(int start_blk, int end_blk)  # -------------------------------------------------------------------...
        mblock_t * copy_block(mblock_t * blk, int new_serial, int cpblk_flags)  # Make a copy of a block. This function makes a simple copy of the bl...
        bint remove_empty_and_unreachable_blocks()  # Delete all empty and unreachable blocks. Blocks marked with MBL_KEE...
        bint merge_blocks()  # Merge blocks. This function merges blocks constituting linear flow....
        int for_all_ops(mop_visitor_t & mv)  # Visit all operands of all instructions.
        int for_all_insns(minsn_visitor_t & mv)  # Visit all instructions. This function visits all instruction and su...
        int for_all_topinsns(minsn_visitor_t & mv)  # Visit all top level instructions.
        mop_t * find_mop(op_parent_info_t * ctx, ea_t ea, bint is_dest, const mlist_t & list)  # Find an operand in the microcode. This function tries to find the o...
        lvar_t & arg(int n)  # Get input argument of the decompiled function.
        const lvar_t & arg(int n) const
        ea_t alloc_fict_ea(ea_t real_ea)  # Allocate a fictional address. This function can be used to allocate...
        ea_t map_fict_ea(ea_t fict_ea) const  # Resolve a fictional address. This function provides a reverse of th...
        const ivl_t & get_std_region(memreg_index_t idx) const  # Get information about various memory regions. We map the stack fram...
        const ivl_t & get_lvars_region() const
        const ivl_t & get_shadow_region() const
        const ivl_t & get_args_region() const
        ivl_t get_stack_region() const
        @staticmethod
        mba_t * deserialize(const uchar * bytes, int nbytes)  # Deserialize a byte sequence into mbl array.
        void save_snapshot(const char * description)  # Create and save microcode snapshot
        mreg_t alloc_kreg(int size, bint check_size)  # Allocate a kernel register.
        void free_kreg(mreg_t reg, int size)  # Free a kernel register. If wrong arguments are passed, this functio...
        merror_t inline_func(codegen_t & cdg, int blknum, mba_ranges_t & ranges, int decomp_flags, int inline_flags)  # @} Inline a range. This function may be called only during the init...
        bint set_lvar_name(lvar_t & v, const char * name, int flagbits)  # -------------------------------------------------------------------...
        bint set_nice_lvar_name(lvar_t & v, const char * name)
        bint set_user_lvar_name(lvar_t & v, const char * name)
    cdef cppclass chain_keeper_t:  # -------------------------------------------------------------------...
        chain_keeper_t(graph_chains_t * _gc)
        block_chains_t & operator[](int idx)
        block_chains_t & front()
        block_chains_t & back()
        int for_all_chains(chain_visitor_t & cv, int gca)
    cdef cppclass mbl_graph_t(simple_graph_t):  # -------------------------------------------------------------------...
        bint is_ud_chain_dirty(gctype_t gctype)  # Is the use-def chain of the specified kind dirty?
        bint is_du_chain_dirty(gctype_t gctype)  # Is the def-use chain of the specified kind dirty?
        int get_chain_stamp() const
        graph_chains_t * get_ud(gctype_t gctype)  # Get use-def chains.
        graph_chains_t * get_du(gctype_t gctype)  # Get def-use chains.
        bint is_redefined_globally(const mlist_t & list, int b1, int b2, const minsn_t * m1, const minsn_t * m2, maymust_t maymust) const  # Is LIST redefined in the graph?
        bint is_used_globally(const mlist_t & list, int b1, int b2, const minsn_t * m1, const minsn_t * m2, maymust_t maymust) const  # Is LIST used in the graph?
        mblock_t * get_mblock(int n) const
    cdef cppclass cdg_insn_iterator_t:  # -------------------------------------------------------------------...
        const mba_t * mba  # to check range
        ea_t ea  # next insn to decode
        ea_t end  # end of the block
        ea_t dslot  # address of the insn in the delay slot
        ea_t severed_branch  # address of the severed branch insn
        bint is_likely_dslot  # execute delay slot only when jumping
        cdg_insn_iterator_t(const mba_t * mba_)
        bint ok() const
        bint has_dslot() const
        bint dslot_with_xrefs() const
        bint is_severed_dslot() const  # the current insn is the severed delayed insn (when this starts a bl...
    cdef cppclass codegen_t:  # -------------------------------------------------------------------...
        mba_t * mba  # ptr to mbl array
        mblock_t * mb  # current basic block
        char ignore_micro  # value of get_ignore_micro() for the insn
        codegen_t()
        void clear()  # -------------------------------------------------------------------...
        merror_t gen_micro()  # Generate microcode for one instruction. The instruction is in INSN
        mreg_t load_operand(int opnum, int flags)  # Generate microcode to load one operand.
        void microgen_completed()  # This method is called when the microcode generation is done
        merror_t prepare_gen_micro()  # Setup internal data to handle new instruction. This method should b...
        mreg_t load_effective_address(int n, int flags)  # Generate microcode to calculate the address of a memory operand.
        bint store_operand(int n, const mop_t & mop, int flags, minsn_t ** outins)  # Generate microcode to store an operand. In case of success an arbit...
        minsn_t * emit(mcode_t code, int width, uval_t l, uval_t r, uval_t d, int offsize)  # Emit one microinstruction. The L, R, D arguments usually mean the r...
        minsn_t * emit(mcode_t code, const mop_t * l, const mop_t * r, const mop_t * d)  # Emit one microinstruction. This variant accepts pointers to operand...
    cdef cppclass hexrays_failure_t:  # Exception object: decompiler failure information
        merror_t code  # MERR_
        ea_t errea  # associated address
        hexrays_failure_t()
        hexrays_failure_t(merror_t c, ea_t ea, const char * buf)
    cdef cppclass vd_failure_t:  # Exception object: decompiler exception
        hexrays_failure_t hf
        vd_failure_t()
        vd_failure_t(merror_t code, ea_t ea, const char * buf)
        vd_failure_t(const hexrays_failure_t & _hf)
    cdef cppclass vd_interr_t(vd_failure_t):  # Exception object: decompiler internal error
        vd_interr_t(ea_t ea, const char * buf)
    cdef cppclass gco_info_t:  # Result of get_current_operand()
        sval_t stkoff  # if stkvar, stack offset
        int regnum  # if register, the register id
        int size  # operand size
        int flags
        bint is_reg() const
        bint is_use() const
        bint is_def() const
        bint append_to_list(mlist_t * list, const mba_t * mba) const  # Append operand info to LIST. This function converts IDA register nu...
        vivl_t cvt_to_ivl() const  # Convert operand info to VIVL. The returned VIVL can be used, for ex...
    cdef cppclass cnumber_t:  # An immediate number
        uint64 _value  # its value
        number_format_t nf  # how to represent it
        cnumber_t(int _opnum)
        bint operator==(const cnumber_t & r) const
        bint operator!=(const cnumber_t & r) const
        bint operator<(const cnumber_t & r) const
        bint operator>(const cnumber_t & r) const
        bint operator<=(const cnumber_t & r) const
        bint operator>=(const cnumber_t & r) const
        int compare(const cnumber_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass var_ref_t:  # Reference to a local variable
        mba_t * mba  # pointer to the underlying micro array
        int idx  # index into lvars_t
        lvar_t & getv() const
        bint operator==(const var_ref_t & r) const
        bint operator!=(const var_ref_t & r) const
        bint operator<(const var_ref_t & r) const
        bint operator>(const var_ref_t & r) const
        bint operator<=(const var_ref_t & r) const
        bint operator>=(const var_ref_t & r) const
        int compare(const var_ref_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass treeloc_t:  # Ctree location. Used to denote comment locations.
        ea_t ea
        item_preciser_t itp
        bint operator<(const treeloc_t & r) const
        bint operator==(const treeloc_t & r) const
    cdef cppclass citem_cmt_t:  # Ctree item comment. For each comment we remember its body and the f...
        bint used  # the comment has been retrieved?
        citem_cmt_t()
        citem_cmt_t(const char * s)
    cdef cppclass citem_locator_t:  # Generic ctree item locator. It can be used for instructions and som...
        ea_t ea  # citem address
        ctype_t op  # citem operation
        citem_locator_t()
        citem_locator_t(ea_t _ea, ctype_t _op)
        citem_locator_t(const citem_t * i)
        bint operator==(const citem_locator_t & r) const
        bint operator!=(const citem_locator_t & r) const
        bint operator<(const citem_locator_t & r) const
        bint operator>(const citem_locator_t & r) const
        bint operator<=(const citem_locator_t & r) const
        bint operator>=(const citem_locator_t & r) const
        int compare(const citem_locator_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass bit_bound_t:  # -------------------------------------------------------------------...
        int16 nbits  # total number of non-zero bits. we cannot guarantee that they are ze...
        int16 sbits  # number of sign bits (they can be either 0 or 1, all of them) if bit...
        bit_bound_t(int n, int s)
    cdef cppclass citem_t:  # -------------------------------------------------------------------...
        ea_t ea  # address that corresponds to the item. may be BADADDR
        ctype_t op  # item type
        int label_num  # label number. -1 means no label. items of the expression types (cot...
        int index  # an index in cfunc_t::treeitems. meaningful only after print_func()
        citem_t(ctype_t o)
        void swap(citem_t & r)  # Swap two citem_t
        bint is_expr() const  # Is an expression?
        bint contains_expr(const cexpr_t * e) const  # Does the item contain an expression?
        bint contains_label() const  # Does the item contain a label?
        const citem_t * find_parent_of(const citem_t * item) const  # Find parent of the specified item.
        citem_t * find_parent_of(const citem_t * item)
        citem_t * find_closest_addr(ea_t _ea)  # -------------------------------------------------------------------...
    cdef cppclass cexpr_t(citem_t):  # Ctree item: expression. Depending on the exact expression item type...
        cnumber_t * n  # used for cot_num
        fnumber_t * fpc  # used for cot_fnum
        cinsn_t * insn  # an embedded statement, they are prohibited at the final maturity st...
        char * helper  # helper name (used for cot_helper)
        char * string  # utf8 string constant, user representation (used for cot_str)
        uint32 exflags  # EXFL_
        bint cpadone() const  # @} Pointer arithmetic correction done for this expression?
        bint is_odd_lvalue() const
        bint is_fpop() const
        bint is_cstr() const
        bint is_type_partial() const
        bint is_undef_val() const
        bint is_jumpout() const
        bint is_vftable() const
        void set_cpadone()
        void set_vftable()
        void set_type_partial(bint val)
        cexpr_t()
        cexpr_t(ctype_t cexpr_op, cexpr_t * _x, cexpr_t * _y, cexpr_t * _z)
        cexpr_t(mba_t * mba, const lvar_t & v)
        cexpr_t(const cexpr_t & r)
        void swap(cexpr_t & r)
        cexpr_t & operator=(const cexpr_t & r)
        cexpr_t & assign(const cexpr_t & r)  # -------------------------------------------------------------------...
        bint operator==(const cexpr_t & r) const
        bint operator!=(const cexpr_t & r) const
        bint operator<(const cexpr_t & r) const
        bint operator>(const cexpr_t & r) const
        bint operator<=(const cexpr_t & r) const
        bint operator>=(const cexpr_t & r) const
        int compare(const cexpr_t & r) const  # -------------------------------------------------------------------...
        void replace_by(cexpr_t * r)  # Replace the expression. The children of the expression are abandone...
        void cleanup()  # Cleanup the expression. This function properly deletes all children...
        void calc_type(bint recursive)  # Calculate the type of the expression. Use this function to calculat...
        bint equal_effect(const cexpr_t & r) const  # Compare two expressions. This function tries to compare two express...
        bint is_child_of(const citem_t * parent) const  # Verify if the specified item is our parent.
        bint contains_operator(ctype_t needed_op, int times) const  # Check if the expression contains the specified operator.
        bint contains_comma(int times) const  # Does the expression contain a comma operator?
        bint contains_insn(int times) const  # Does the expression contain an embedded statement operator?
        bint contains_insn_or_label() const  # Does the expression contain an embedded statement operator or a label?
        bint contains_comma_or_insn_or_label(int maxcommas) const  # Does the expression contain a comma operator or an embedded stateme...
        bint is_nice_expr() const  # Is nice expression? Nice expressions do not contain comma operators...
        bint is_nice_cond() const  # Is nice condition?. Nice condition is a nice expression of the bool...
        bint is_call_object_of(const citem_t * parent) const  # Is call object?
        bint is_call_arg_of(const citem_t * parent) const  # Is call argument?
        bint is_type_unsigned() const  # Is expression unsigned?
        bint is_type_signed() const  # Is expression signed?
        bit_bound_t get_high_nbit_bound() const  # Get max number of bits that can really be used by the expression. F...
        int get_low_nbit_bound() const  # Get min number of bits that are certainly required to represent the...
        bint requires_lvalue(const cexpr_t * child) const  # Check if the expression requires an lvalue.
        bint has_side_effects() const  # Check if the expression has side effects. Calls, pre/post inc/dec, ...
        bint like_boolean() const  # Does the expression look like a boolean expression? In other words,...
        bint is_aliasable() const  # Check if the expression if aliasable. Simple registers and non-alia...
        uint64 numval() const  # Get numeric value of the expression. This function can be called on...
        bint is_const_value(uint64 _v) const  # Check if the expression is a number with the specified value.
        bint is_negative_const() const  # Check if the expression is a negative number.
        bint is_non_negative_const() const  # Check if the expression is a non-negative number.
        bint is_non_zero_const() const  # Check if the expression is a non-zero number.
        bint is_zero_const() const  # Check if the expression is a zero.
        bint is_value_used(const citem_t * parent) const  # Does the PARENT need the expression value
        bint get_const_value(uint64 * out) const  # Get expression value.
        bint maybe_ptr() const  # May the expression be a pointer?
        cexpr_t * get_ptr_or_array()  # Find pointer or array child.
        const cexpr_t * find_op(ctype_t _op) const  # Find the child with the specified operator.
        cexpr_t * find_op(ctype_t _op)
        const cexpr_t * find_num_op() const  # Find the operand with a numeric value
        cexpr_t * find_num_op()
        const cexpr_t * find_ptr_or_array(bint remove_eqsize_casts) const  # Find the pointer operand. This function returns the pointer operand...
        const cexpr_t * theother(const cexpr_t * what) const  # Get the other operand. This function returns the other operand (not...
        cexpr_t * theother(const cexpr_t * what)
        bint get_1num_op(cexpr_t ** o1, cexpr_t ** o2)  # these are inline functions, see below
        bint get_1num_op(const cexpr_t ** o1, const cexpr_t ** o2) const
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass ceinsn_t:  # Statement with an expression. This is a base class for various stat...
        cexpr_t expr  # Expression of the statement
    cdef cppclass cif_t(ceinsn_t):  # If statement
        cinsn_t * ithen  # Then-branch of the if-statement
        cinsn_t * ielse  # Else-branch of the if-statement. May be nullptr.
        cif_t()
        cif_t(const cif_t & r)
        cif_t & operator=(const cif_t & r)
        cif_t & assign(const cif_t & r)  # -------------------------------------------------------------------...
        bint operator==(const cif_t & r) const
        bint operator!=(const cif_t & r) const
        bint operator<(const cif_t & r) const
        bint operator>(const cif_t & r) const
        bint operator<=(const cif_t & r) const
        bint operator>=(const cif_t & r) const
        int compare(const cif_t & r) const  # -------------------------------------------------------------------...
        void cleanup()  # -------------------------------------------------------------------...
    cdef cppclass cloop_t(ceinsn_t):  # Base class for loop statements
        cinsn_t * body
        cloop_t(cinsn_t * b)
        cloop_t(const cloop_t & r)
        cloop_t & operator=(const cloop_t & r)
        cloop_t & assign(const cloop_t & r)  # -------------------------------------------------------------------...
        void cleanup()
    cdef cppclass cfor_t(cloop_t):  # For-loop
        cexpr_t init  # Initialization expression
        cexpr_t step  # Step expression
        bint operator==(const cfor_t & r) const
        bint operator!=(const cfor_t & r) const
        bint operator<(const cfor_t & r) const
        bint operator>(const cfor_t & r) const
        bint operator<=(const cfor_t & r) const
        bint operator>=(const cfor_t & r) const
        int compare(const cfor_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass cwhile_t(cloop_t):  # While-loop
        bint operator==(const cwhile_t & r) const
        bint operator!=(const cwhile_t & r) const
        bint operator<(const cwhile_t & r) const
        bint operator>(const cwhile_t & r) const
        bint operator<=(const cwhile_t & r) const
        bint operator>=(const cwhile_t & r) const
        int compare(const cwhile_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass cdo_t(cloop_t):  # Do-loop
        bint operator==(const cdo_t & r) const
        bint operator!=(const cdo_t & r) const
        bint operator<(const cdo_t & r) const
        bint operator>(const cdo_t & r) const
        bint operator<=(const cdo_t & r) const
        bint operator>=(const cdo_t & r) const
        int compare(const cdo_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass creturn_t(ceinsn_t):  # Return statement
        bint operator==(const creturn_t & r) const
        bint operator!=(const creturn_t & r) const
        bint operator<(const creturn_t & r) const
        bint operator>(const creturn_t & r) const
        bint operator<=(const creturn_t & r) const
        bint operator>=(const creturn_t & r) const
        int compare(const creturn_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass cgoto_t:  # Goto statement
        int label_num  # Target label number
        void print(const citem_t * parent, int indent, vc_printer_t & vp) const
        bint operator==(const cgoto_t & r) const
        bint operator!=(const cgoto_t & r) const
        bint operator<(const cgoto_t & r) const
        bint operator>(const cgoto_t & r) const
        bint operator<=(const cgoto_t & r) const
        bint operator>=(const cgoto_t & r) const
        int compare(const cgoto_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass casm_t:  # asm statement
        casm_t(ea_t ea)
        casm_t(const casm_t & r)
        bint operator==(const casm_t & r) const
        bint operator!=(const casm_t & r) const
        bint operator<(const casm_t & r) const
        bint operator>(const casm_t & r) const
        bint operator<=(const casm_t & r) const
        bint operator>=(const casm_t & r) const
        int compare(const casm_t & r) const  # -------------------------------------------------------------------...
        void print(const citem_t * parent, int indent, vc_printer_t & vp) const
        bint one_insn() const
    cdef cppclass cinsn_t(citem_t):  # Ctree item: statement. Depending on the exact statement type, vario...
        cblock_t * cblock  # details of block-statement
        cexpr_t * cexpr  # details of expression-statement
        cif_t * cif  # details of if-statement
        cfor_t * cfor  # details of for-statement
        cwhile_t * cwhile  # details of while-statement
        cdo_t * cdo  # details of do-statement
        cswitch_t * cswitch  # details of switch-statement
        creturn_t * creturn  # details of return-statement
        cgoto_t * cgoto  # details of goto-statement
        casm_t * casm  # details of asm-statement
        ctry_t * ctry  # details of try-statement
        cthrow_t * cthrow  # details of throw-statement
        cinsn_t()
        cinsn_t(const cinsn_t & r)
        void swap(cinsn_t & r)
        cinsn_t & operator=(const cinsn_t & r)
        cinsn_t & assign(const cinsn_t & r)  # -------------------------------------------------------------------...
        bint operator==(const cinsn_t & r) const
        bint operator!=(const cinsn_t & r) const
        bint operator<(const cinsn_t & r) const
        bint operator>(const cinsn_t & r) const
        bint operator<=(const cinsn_t & r) const
        bint operator>=(const cinsn_t & r) const
        int compare(const cinsn_t & r) const  # -------------------------------------------------------------------...
        void replace_by(cinsn_t * r)  # Replace the statement. The children of the statement are abandoned ...
        void cleanup()  # Cleanup the statement. This function properly deletes all children ...
        void zero()  # Overwrite with zeroes without cleaning memory or deleting children
        cinsn_t & new_insn(ea_t insn_ea)  # Create a new statement. The current statement must be a block. The ...
        cif_t & create_if(cexpr_t * cnd)  # Create a new if-statement. The current statement must be a block. T...
        void print(int indent, vc_printer_t & vp, use_curly_t use_curly) const  # Print the statement into many lines.
        bint is_ordinary_flow() const  # Check if the statement passes execution to the next statement.
        bint contains_insn(ctype_t type, int times) const  # Check if the statement contains a statement of the specified type.
        bint contains_free_break() const  # Check if the statement has free break statements.
        bint contains_free_continue() const  # Check if the statement has free continue statements.
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass cblock_t:  # Compound statement (curly braces)
        bint operator==(const cblock_t & r) const
        bint operator!=(const cblock_t & r) const
        bint operator<(const cblock_t & r) const
        bint operator>(const cblock_t & r) const
        bint operator<=(const cblock_t & r) const
        bint operator>=(const cblock_t & r) const
        int compare(const cblock_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass carg_t(cexpr_t):  # Function argument
        bint is_vararg  # is a vararg (matches ...)
        void consume_cexpr(cexpr_t * e)
        bint operator==(const carg_t & r) const
        bint operator!=(const carg_t & r) const
        bint operator<(const carg_t & r) const
        bint operator>(const carg_t & r) const
        bint operator<=(const carg_t & r) const
        bint operator>=(const carg_t & r) const
        int compare(const carg_t & r) const
    cdef cppclass carglist_t:  # Function argument list
        int flags  # call flags
        carglist_t()
        bint operator==(const carglist_t & r) const
        bint operator!=(const carglist_t & r) const
        bint operator<(const carglist_t & r) const
        bint operator>(const carglist_t & r) const
        bint operator<=(const carglist_t & r) const
        bint operator>=(const carglist_t & r) const
        int compare(const carglist_t & r) const  # -------------------------------------------------------------------...
        int print(int curpos, vc_printer_t & vp) const
    cdef cppclass ccase_t(cinsn_t):  # Switch case. Usually cinsn_t is a block
        bint operator==(const ccase_t & r) const
        bint operator!=(const ccase_t & r) const
        bint operator<(const ccase_t & r) const
        bint operator>(const ccase_t & r) const
        bint operator<=(const ccase_t & r) const
        bint operator>=(const ccase_t & r) const
        int compare(const ccase_t & r) const  # -------------------------------------------------------------------...
        void set_insn(cinsn_t * i)
        int size() const
        const uint64 & value(int i) const
    cdef cppclass ccases_t:  # Vector of switch cases
        bint operator==(const ccases_t & r) const
        bint operator!=(const ccases_t & r) const
        bint operator<(const ccases_t & r) const
        bint operator>(const ccases_t & r) const
        bint operator<=(const ccases_t & r) const
        bint operator>=(const ccases_t & r) const
        int compare(const ccases_t & r) const  # -------------------------------------------------------------------...
        int find_value(uint64 v) const
    cdef cppclass cswitch_t(ceinsn_t):  # Switch statement
        cnumber_t mvnf  # Maximal switch value and number format
        ccases_t cases  # Switch cases: values and instructions
        bint operator==(const cswitch_t & r) const
        bint operator!=(const cswitch_t & r) const
        bint operator<(const cswitch_t & r) const
        bint operator>(const cswitch_t & r) const
        bint operator<=(const cswitch_t & r) const
        bint operator>=(const cswitch_t & r) const
        int compare(const cswitch_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass catchexpr_t:  # Catch expression
        cexpr_t obj  # the caught object. if obj.op==cot_empty, no object. ideally, obj.op...
        bint operator==(const catchexpr_t & r) const
        bint operator!=(const catchexpr_t & r) const
        bint operator<(const catchexpr_t & r) const
        bint operator>(const catchexpr_t & r) const
        bint operator<=(const catchexpr_t & r) const
        bint operator>=(const catchexpr_t & r) const
        int compare(const catchexpr_t & r) const  # -------------------------------------------------------------------...
        void swap(catchexpr_t & r)
        bint is_catch_all() const
    cdef cppclass ccatch_t(cblock_t):  # Catch clause: "catch ( type obj )"
        bint operator==(const ccatch_t & r) const
        bint operator!=(const ccatch_t & r) const
        bint operator<(const ccatch_t & r) const
        bint operator>(const ccatch_t & r) const
        bint operator<=(const ccatch_t & r) const
        bint operator>=(const ccatch_t & r) const
        int compare(const ccatch_t & r) const  # -------------------------------------------------------------------...
        bint is_catch_all() const
        void swap(ccatch_t & r)
    cdef cppclass ctry_t(cblock_t):  # C++ Try statement. This structure is also used to represent wind st...
        int old_state  # old state number (internal, MSVC related)
        int new_state  # new state number (internal, MSVC related)
        bint is_wind  # if false, then try/catch
        bint operator==(const ctry_t & r) const
        bint operator!=(const ctry_t & r) const
        bint operator<(const ctry_t & r) const
        bint operator>(const ctry_t & r) const
        bint operator<=(const ctry_t & r) const
        bint operator>=(const ctry_t & r) const
        int compare(const ctry_t & r) const  # -------------------------------------------------------------------...
        void print(const citem_t * parent, int indent, vc_printer_t & vp) const
    cdef cppclass cthrow_t(ceinsn_t):  # Throw statement
        bint operator==(const cthrow_t & r) const
        bint operator!=(const cthrow_t & r) const
        bint operator<(const cthrow_t & r) const
        bint operator>(const cthrow_t & r) const
        bint operator<=(const cthrow_t & r) const
        bint operator>=(const cthrow_t & r) const
        int compare(const cthrow_t & r) const  # -------------------------------------------------------------------...
    cdef cppclass cblock_pos_t:  # -------------------------------------------------------------------...
        cblock_t * blk  # cinsn_t::cblock or cinsn_t::ctry or cinsn_t::ctry->catchs[x]
        int p  # iterator pointing to the current item
        bint is_first_insn() const
        cinsn_t * insn() const
        cinsn_t * prev_insn()
    cdef cppclass ctree_visitor_t:  # A generic helper class that is used for ctree traversal. When trave...
        int cv_flags  # CV_
        bint maintain_parents() const  # @} Should the parent information by maintained?
        bint must_prune() const  # Should the traversal skip the children of the current item?
        bint must_restart() const  # Should the traversal restart?
        bint is_postorder() const  # Should the leave...() functions be called?
        bint only_insns() const  # Should all expressions be automatically pruned?
        void prune_now()  # Prune children. This function may be called by a visitor() to skip ...
        void clr_prune()  # Do not prune children. This is an internal function, no need to cal...
        void set_restart()  # Restart the travesal. Meaningful only in apply_to_exprs()
        void clr_restart()  # Do not restart. This is an internal function, no need to call it.
        ctree_visitor_t(int _flags)  # Constructor. This constructor can be used with CV_FAST, CV_PARENTS ...
        int apply_to(citem_t * item, citem_t * parent)  # Traverse ctree. The traversal will start at the specified item and ...
        int apply_to_exprs(citem_t * item, citem_t * parent)  # Traverse only expressions. The traversal will start at the specifie...
        citem_t * parent_item()  # Get parent of the current item as an item (statement or expression)
        cexpr_t * parent_expr()  # Get parent of the current item as an expression
        cinsn_t * parent_insn()  # Get parent of the current item as a statement
        int visit_insn(cinsn_t * arg33)  # Visit a statement. This is a visitor function which should be overr...
        int visit_expr(cexpr_t * arg33)  # Visit an expression. This is a visitor function which should be ove...
        int leave_insn(cinsn_t * arg33)  # Visit a statement after having visited its children. This is a visi...
        int leave_expr(cexpr_t * arg33)  # Visit an expression after having visited its children. This is a vi...
    cdef cppclass ctree_parentee_t(ctree_visitor_t):  # A helper ctree traversal class that maintains parent information
        ctree_parentee_t(bint post)
        bint recalc_parent_types()  # Recalculate type of parent nodes. If a node type has been changed, ...
    cdef cppclass cfunc_parentee_t(ctree_parentee_t):  # Class to traverse the whole function.
        cfunc_t * func  # Pointer to current function
        cfunc_parentee_t(cfunc_t * f, bint post)
    cdef cppclass ctree_anchor_t:  # -------------------------------------------------------------------...
        uval_t value
        int get_index() const
        item_preciser_t get_itp() const
        bint is_valid_anchor() const
        bint is_citem_anchor() const
        bint is_lvar_anchor() const
        bint is_itp_anchor() const
        bint is_blkcmt_anchor() const
    cdef cppclass ctree_item_t:  # Cursor item. Information about the item under the cursor
        cursor_item_type_t citype  # Item type
        citem_t * it
        cexpr_t * e  # VDI_EXPR: Expression
        cinsn_t * i  # VDI_EXPR: Statement
        lvar_t * l  # VDI_LVAR: Local variable
        cfunc_t * f  # VDI_FUNC: Function
        treeloc_t loc  # VDI_TAIL: Line tail
        void verify(const mba_t * mba) const
        lvar_t * get_lvar() const  # Get pointer to local variable. If the current item is a local varia...
        ea_t get_ea() const  # Get address of the current item. Each ctree item has an address.
        int get_label_num(int gln_flags) const  # Get label number of the current item.
        bint is_citem() const  # Is the current item is a ctree item?
        const char * dstr() const  # -------------------------------------------------------------------...
    cdef cppclass cfunc_t:  # Ctree level forward definitions:
        ea_t entry_ea  # function entry address
        mba_t * mba  # underlying microcode
        cinsn_t body  # function body, must be a block
        ctree_maturity_t maturity  # maturity level
        user_labels_t * user_labels  # user-defined labels.
        user_cmts_t * user_cmts  # user-defined comments.
        user_numforms_t * numforms  # user-defined number formats.
        user_iflags_t * user_iflags  # user-defined item flags CIT_
        user_unions_t * user_unions  # user-defined union field selections.
        int refcnt  # reference count to this object. use cfuncptr_t
        int statebits  # current cfunc_t state. see CFS_
        eamap_t * eamap  # ea->insn map. use get_eamap
        boundaries_t * boundaries  # map of instruction boundaries. use get_boundaries
        int hdrlines  # number of lines in the declaration area
        cfunc_t(mba_t * mba)
        void release()
        void build_c_tree()  # Generate the function body. This function (re)generates the functio...
        void verify(allow_unused_labels_t aul, bint even_without_debugger) const  # Verify the ctree. This function verifies the ctree. If the ctree is...
        void print_func(vc_printer_t & vp) const  # Print function text.
        lvars_t * get_lvars()  # Get vector of local variables.
        sval_t get_stkoff_delta()  # Get stack offset delta. The local variable stack offsets retrieved ...
        citem_t * find_label(int label)  # Find the label.
        void remove_unused_labels()  # Remove unused labels. This function checks what labels are really u...
        const char * get_user_cmt(const treeloc_t & loc, cmt_retrieval_type_t rt) const  # Retrieve a user defined comment.
        void set_user_cmt(const treeloc_t & loc, const char * cmt)  # Set a user defined comment. This function stores the specified comm...
        int32 get_user_iflags(const citem_locator_t & loc) const  # Retrieve citem iflags.
        void set_user_iflags(const citem_locator_t & loc, int32 iflags)  # Set citem iflags.
        bint has_orphan_cmts() const  # Check if there are orphan comments.
        int del_orphan_cmts()  # Delete all orphan comments. The save_user_cmts() function must be c...
        void save_user_labels() const  # Save user-defined labels into the database
        void save_user_cmts() const  # Save user-defined comments into the database
        void save_user_numforms() const  # Save user-defined number formats into the database
        void save_user_iflags() const  # Save user-defined iflags into the database
        void save_user_unions() const  # Save user-defined union field selections into the database
        bint get_line_item(const char * line, int x, bint is_ctree_line, ctree_item_t * phead, ctree_item_t * pitem, ctree_item_t * ptail)  # Get ctree item for the specified cursor position.
        eamap_t & get_eamap()  # Get pointer to ea->insn map. This function initializes eamap if not...
        boundaries_t & get_boundaries()  # Get pointer to map of instruction boundaries. This function initial...
        void refresh_func_ctext()  # Refresh ctext after a ctree modification. This function informs the...
        void recalc_item_addresses()  # Recalculate item adresses. This function may be required after shuf...
        bint find_item_coords(const citem_t * item, int * px, int * py)  # -------------------------------------------------------------------...
        bint locked() const
    cdef cppclass ctext_position_t:  # -------------------------------------------------------------------...
        int lnnum  # Line number
        int x  # x coordinate of the cursor within the window
        int y  # y coordinate of the cursor within the window
        bint in_ctree(int hdrlines) const  # Is the cursor in the variable/type declaration area?
        bint operator==(const ctext_position_t & r) const  # Comparison operators
        bint operator!=(const ctext_position_t & r) const  # Comparison operators
        bint operator<(const ctext_position_t & r) const  # Comparison operators
        bint operator>(const ctext_position_t & r) const  # Comparison operators
        bint operator<=(const ctext_position_t & r) const  # Comparison operators
        bint operator>=(const ctext_position_t & r) const  # Comparison operators
        int compare(const ctext_position_t & r) const  # Comparison operators
        ctext_position_t(int _lnnum, int _x, int _y)
    cdef cppclass history_item_t(ctext_position_t):  # Navigation history item. Holds information about interactive decomp...
        ea_t func_ea  # The entry address of the decompiled function
        ea_t curr_ea  # Current address
        ea_t end  # BADADDR-decompile a function; otherwise end of the range
        history_item_t(ea_t fea, ea_t cea, int _lnnum, int _x, int _y)
        history_item_t(ea_t fea, ea_t cea, const ctext_position_t & p)
    cdef cppclass vdui_t:  # -------------------------------------------------------------------...
        int flags  # VDUI_
        int view_idx  # pseudocode window index (0..)
        mba_t * mba  # pointer to underlying microcode
        merror_t last_code  # result of the last user action. See MERR_
        ctext_position_t cpos  # Current ctext position
        ctree_item_t head  # First ctree item on the current line (for block comments)
        ctree_item_t item  # Current ctree item
        ctree_item_t tail  # Tail ctree item on the current line (for indented comments)
        bint visible() const  # Is the pseudocode window visible? if not, it might be invisible or ...
        bint valid() const  # Does the pseudocode window contain valid code? It can become invali...
        bint locked() const  # Does the pseudocode window contain valid code? We lock windows befo...
        void set_visible(bint v)
        void set_valid(bint v)
        bint set_locked(bint v)  # -------------------------------------------------------------------...
        vdui_t()
        void refresh_view(bint redo_mba)  # Refresh pseudocode window. This is the highest level refresh functi...
        void refresh_ctext(bint activate)  # Refresh pseudocode window. This function refreshes the pseudocode w...
        bint in_ctree() const  # Is the current item a statement? /
        cnumber_t * get_number()  # Get current number. If the current item is a number, return pointer...
        int get_current_label()  # Get current label. If there is a label under the cursor, return its...
        void clear()  # Clear the pseudocode window. It deletes the current function and mi...
        bint refresh_cpos(input_device_t idv)  # Refresh the current position. This function refreshes the cpos field.
        bint get_current_item(input_device_t idv)  # Get current item. This function refreshes the cpos, item, tail fields.
        bint ui_rename_lvar(lvar_t * v)  # Rename local variable. This function displays a dialog box and allo...
        bint rename_lvar(lvar_t * v, const char * name, bint is_user_name)  # Rename local variable. This function permanently renames a local va...
        bint ui_set_call_type(const cexpr_t * e)  # Set type of a function call This function displays a dialog box and...
        bint ui_set_lvar_type(lvar_t * v)  # Set local variable type. This function displays a dialog box and al...
        bint set_noptr_lvar(lvar_t * v)  # Inform that local variable should have a non-pointer type This func...
        bint ui_edit_lvar_cmt(lvar_t * v)  # Set local variable comment. This function displays a dialog box and...
        bint set_lvar_cmt(lvar_t * v, const char * cmt)  # Set local variable comment. This function permanently sets a variab...
        bint ui_map_lvar(lvar_t * v)  # Map a local variable to another. This function displays a variable ...
        bint ui_unmap_lvar(lvar_t * v)  # Unmap a local variable. This function displays list of variables ma...
        bint map_lvar(lvar_t * from_, lvar_t * to)  # Map a local variable to another. This function permanently maps one...
        bint set_global_type(ea_t ea)  # Set global item type. This function displays a dialog box and allow...
        bint rename_global(ea_t ea)  # Rename global item. This function displays a dialog box and allows ...
        bint rename_label(int label)  # Rename a label. This function displays a dialog box and allows the ...
        bint jump_enter(input_device_t idv, int omflags)  # Process the Enter key. This function jumps to the definition of the...
        bint ctree_to_disasm()  # Jump to disassembly. This function jumps to the address in the disa...
        cmt_type_t calc_cmt_type(int lnnum, cmt_type_t cmttype) const  # Check if the specified line can have a comment. Due to the coordina...
        bint edit_cmt(const treeloc_t & loc)  # Edit an indented comment. This function displays a dialog box and a...
        bint edit_func_cmt()  # Edit a function comment. This function displays a dialog box and al...
        bint del_orphan_cmts()  # Delete all orphan comments. Delete all orphan comments and refresh ...
        bint set_num_radix(int base)  # Change number base. This function changes the current number repres...
        bint set_num_enum()  # Convert number to symbolic constant. This function displays a dialo...
        bint set_num_stroff()  # Convert number to structure field offset. Currently not implemented.
        bint invert_sign()  # Negate a number. This function negates the current number.
        bint invert_bits()  # Bitwise negate a number. This function inverts all bits of the curr...
        bint collapse_item(bint hide)  # Collapse/uncollapse item. This function collapses the current item.
        bint collapse_lvars(bint hide)  # Collapse/uncollapse local variable declarations.
        bint split_item(bint split)  # Split/unsplit item. This function splits the current assignment exp...
    cdef cppclass ui_stroff_op_t:  # Operand represention
        uval_t offset  # operand offset, will be used when calculating the UDT path
        bint operator==(const ui_stroff_op_t & r) const
        bint operator!=(const ui_stroff_op_t & r) const
    cdef cppclass ui_stroff_applicator_t:  # Callback to apply the selection
        pass
    cdef cppclass user_numforms_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass lvar_mapping_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass udcall_map_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass user_cmts_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass user_iflags_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass user_unions_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass user_labels_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass eamap_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass boundaries_iterator_t:  # -------------------------------------------------------------------...
        pass
    cdef cppclass block_chains_iterator_t:  # -------------------------------------------------------------------...
        pass
    void * hexrays_alloc(int size)
    void hexrays_free(void * ptr)  # -------------------------------------------------------------------...
    uvlr_t max_vlr_value(int size)  # -------------------------------------------------------------------...
    uvlr_t min_vlr_svalue(int size)
    uvlr_t max_vlr_svalue(int size)
    bint is_unsigned_cmpop(cmpop_t cmpop)
    bint is_signed_cmpop(cmpop_t cmpop)
    bint is_cmpop_with_eq(cmpop_t cmpop)
    bint is_cmpop_without_eq(cmpop_t cmpop)
    bint is_may_access(maymust_t maymust)  # do not include global memory into the spoiled list of a call
    bint must_mcode_close_block(mcode_t mcode, bint including_calls)  # Must an instruction with the given opcode be the last one in a bloc...
    bint is_mcode_propagatable(mcode_t mcode)  # May opcode be propagated? Such opcodes can be used in sub-instructi...
    bint is_mcode_addsub(mcode_t mcode)  # Is add or sub instruction?
    bint is_mcode_xdsu(mcode_t mcode)  # Is xds or xdu instruction? We use 'xdsu' as a shortcut for 'xds or ...
    bint is_mcode_set(mcode_t mcode)  # Is a 'set' instruction? (an instruction that sets a condition code)
    bint is_mcode_set1(mcode_t mcode)  # Is a 1-operand 'set' instruction? Only 'sets' is in this group
    bint is_mcode_j1(mcode_t mcode)  # Is a 1-operand conditional jump instruction? Only 'jcnd' is in this...
    bint is_mcode_jcond(mcode_t mcode)  # Is a conditional jump?
    bint is_mcode_convertible_to_jmp(mcode_t mcode)  # Is a 'set' instruction that can be converted into a conditional jump?
    bint is_mcode_convertible_to_set(mcode_t mcode)  # Is a conditional jump instruction that can be converted into a 'set'?
    bint is_mcode_call(mcode_t mcode)  # Is a call instruction? (direct or indirect)
    bint is_mcode_fpu(mcode_t mcode)  # Must be an FPU instruction?
    bint is_mcode_commutative(mcode_t mcode)  # Is a commutative instruction?
    bint is_mcode_shift(mcode_t mcode)  # Is a shift instruction?
    bint is_mcode_divmod(mcode_t op)  # Is a kind of div or mod instruction?
    bint has_mcode_seloff(mcode_t op)  # Is an instruction with the selector/offset pair?
    mcode_t set2jcnd(mcode_t code)  # Convert setX opcode into corresponding jX opcode This function reli...
    mcode_t jcnd2set(mcode_t code)  # Convert setX opcode into corresponding jX opcode This function reli...
    mcode_t negate_mcode_relation(mcode_t code)  # Negate a conditional opcode. Conditional jumps can be negated, exam...
    mcode_t swap_mcode_relation(mcode_t code)  # Swap a conditional opcode. Only conditional jumps and set instructi...
    mcode_t get_signed_mcode(mcode_t code)  # Return the opcode that performs signed operation. Examples: jae -> ...
    mcode_t get_unsigned_mcode(mcode_t code)  # Return the opcode that performs unsigned operation. Examples: jl ->...
    bint is_signed_mcode(mcode_t code)  # Does the opcode perform a signed operation?
    bint is_unsigned_mcode(mcode_t code)  # Does the opcode perform a unsigned operation?
    bint mcode_modifies_d(mcode_t mcode)  # Does the 'd' operand gets modified by the instruction? Example: "ad...
    bint is_type_correct(const type_t * ptr)  # Verify a type string.
    bint is_ptr_or_array(type_t t)  # Is a pointer or array type?
    bint is_paf(type_t t)  # Is a pointer, array, or function type?
    bint arglocs_overlap(const vdloc_t & loc1, int w1, const vdloc_t & loc2, int w2)  # -------------------------------------------------------------------...
    bint restore_user_lvar_settings(lvar_uservec_t * lvinf, ea_t func_ea)  # Restore user defined local variable settings in the database.
    void save_user_lvar_settings(ea_t func_ea, const lvar_uservec_t & lvinf)  # Save user defined local variable settings into the database.
    bint modify_user_lvars(ea_t entry_ea, user_lvar_modifier_t & mlv)  # Modify saved local variable settings.
    bint modify_user_lvar_info(ea_t func_ea, uint mli_flags, const lvar_saved_info_t & info)  # Modify saved local variable settings of one variable.
    bint locate_lvar(lvar_locator_t * out, ea_t func_ea, const char * varname)  # Find a variable by name.
    bint rename_lvar(ea_t func_ea, const char * oldname, const char * newname)  # Rename a local variable.
    bint restore_user_defined_calls(udcall_map_t * udcalls, ea_t func_ea)  # Restore user defined function calls from the database.
    void save_user_defined_calls(ea_t func_ea, const udcall_map_t & udcalls)  # Save user defined local function calls into the database.
    bint parse_user_call(udcall_t * udc, const char * decl, bint silent)  # Convert function type declaration into internal structure
    merror_t convert_to_user_call(const udcall_t & udc, codegen_t & cdg)  # try to generate user-defined call for an instruction
    bint install_microcode_filter(microcode_filter_t * filter, bint install)  # register/unregister non-standard microcode generator
    const mlist_t & get_temp_regs()  # -------------------------------------------------------------------...
    bint is_kreg(mreg_t r)  # Is a kernel register? Kernel registers are temporary registers that...
    mreg_t reg2mreg(int reg)  # Map a processor register to a microregister.
    int mreg2reg(mreg_t reg, int width)  # Map a microregister to a processor register.
    void install_optinsn_handler(optinsn_t * opt)  # Install an instruction level custom optimizer
    bint remove_optinsn_handler(optinsn_t * opt)  # Remove an instruction level custom optimizer
    void install_optblock_handler(optblock_t * opt)  # Install a block level custom optimizer.
    bint remove_optblock_handler(optblock_t * opt)  # Remove a block level custom optimizer
    const minsn_t * getf_reginsn(const minsn_t * ins)  # Skip assertions forward
    const minsn_t * getb_reginsn(const minsn_t * ins)  # Skip assertions backward
    minsn_t * getf_reginsn(minsn_t * ins)
    minsn_t * getb_reginsn(minsn_t * ins)
    bint change_hexrays_config(const char * directive)  # -------------------------------------------------------------------...
    const char * get_hexrays_version()  # -------------------------------------------------------------------...
    vdui_t * open_pseudocode(ea_t ea, int flags)  # Open pseudocode window. The specified function is decompiled and th...
    void send_database(const hexrays_failure_t & err, bint silent)  # Send the database to Hex-Rays. This function sends the current data...
    bint get_current_operand(gco_info_t * out)  # Get the instruction operand under the cursor. This function determi...
    void remitem(const citem_t * e)  # -------------------------------------------------------------------...
    ctype_t negated_relation(ctype_t op)  # Negate a comparison operator. For example, cot_sge becomes cot_slt
    ctype_t swapped_relation(ctype_t op)  # Swap a comparison operator. For example, cot_sge becomes cot_sle
    ctype_t asgop(ctype_t cop)  # Convert plain operator into assignment operator. For example, cot_a...
    ctype_t asgop_revert(ctype_t cop)  # Convert assignment operator into plain operator. For example, cot_a...
    bint op_uses_x(ctype_t op)  # Does operator use the 'x' field of cexpr_t?
    bint op_uses_y(ctype_t op)  # Does operator use the 'y' field of cexpr_t?
    bint op_uses_z(ctype_t op)  # Does operator use the 'z' field of cexpr_t?
    bint is_binary(ctype_t op)  # Is binary operator?
    bint is_unary(ctype_t op)  # Is unary operator?
    bint is_relational(ctype_t op)  # Is comparison operator?
    bint is_assignment(ctype_t op)  # Is assignment operator?
    bint accepts_udts(ctype_t op)  # Can operate on UDTs?
    bint is_prepost(ctype_t op)  # Is pre/post increment/decrement operator?
    bint is_commutative(ctype_t op)  # Is commutative operator?
    bint is_additive(ctype_t op)  # Is additive operator?
    bint is_multiplicative(ctype_t op)  # Is multiplicative operator?
    bint is_bitop(ctype_t op)  # Is bit related operator?
    bint is_logical(ctype_t op)  # Is logical operator?
    bint is_loop(ctype_t op)  # Is loop statement code?
    bint is_break_consumer(ctype_t op)  # Does a break statement influence the specified statement code?
    bint is_lvalue(ctype_t op)  # Is Lvalue operator?
    bint accepts_small_udts(ctype_t op)  # Is the operator allowed on small structure or union?
    cexpr_t * lnot(cexpr_t * e)  # Logically negate the specified expression. The specified expression...
    cinsn_t * new_block()  # Create a new block-statement.
    cexpr_t * make_ref(cexpr_t * e)  # Create a reference. This function performs the following conversion...
    cexpr_t * dereference(cexpr_t * e, int ptrsize, bint is_flt)  # Dereference a pointer. This function dereferences a pointer express...
    void save_user_labels(ea_t func_ea, const user_labels_t * user_labels, const cfunc_t * func)  # Save user defined labels into the database.
    void save_user_cmts(ea_t func_ea, const user_cmts_t * user_cmts)  # Save user defined comments into the database.
    void save_user_numforms(ea_t func_ea, const user_numforms_t * numforms)  # Save user defined number formats into the database.
    void save_user_iflags(ea_t func_ea, const user_iflags_t * iflags)  # Save user defined citem iflags into the database.
    void save_user_unions(ea_t func_ea, const user_unions_t * unions)  # Save user defined union field selections into the database.
    user_labels_t * restore_user_labels(ea_t func_ea, const cfunc_t * func)  # Restore user defined labels from the database.
    user_cmts_t * restore_user_cmts(ea_t func_ea)  # Restore user defined comments from the database.
    user_numforms_t * restore_user_numforms(ea_t func_ea)  # Restore user defined number formats from the database.
    user_iflags_t * restore_user_iflags(ea_t func_ea)  # Restore user defined citem iflags from the database.
    user_unions_t * restore_user_unions(ea_t func_ea)  # Restore user defined union field selections from the database.
    void close_hexrays_waitbox()  # Close the waitbox displayed by the decompiler. Useful if DECOMP_NO_...
    mba_t * gen_microcode(const mba_ranges_t & mbr, hexrays_failure_t * hf, const mlist_t * retlist, int decomp_flags, mba_maturity_t reqmat)  # Generate microcode of an arbitrary code snippet
    mba_t * create_empty_mba(const mba_ranges_t & mbr, hexrays_failure_t * hf)  # Create an empty microcode object
    bint mark_cfunc_dirty(ea_t ea, bint close_views)  # Flush the cached decompilation results. Erases a cache entry for th...
    void clear_cached_cfuncs()  # Flush all cached decompilation results.
    bint has_cached_cfunc(ea_t ea)  # Do we have a cached decompilation result for 'ea'?
    const char * get_ctype_name(ctype_t op)  # -------------------------------------------------------------------...
    bint init_hexrays_plugin(int flags)  # -------------------------------------------------------------------...
    void term_hexrays_plugin()  # -------------------------------------------------------------------...
    void user_numforms_clear(user_numforms_t * map)  # -------------------------------------------------------------------...
    int user_numforms_size(user_numforms_t * map)  # -------------------------------------------------------------------...
    void user_numforms_free(user_numforms_t * map)  # -------------------------------------------------------------------...
    user_numforms_t * user_numforms_new()  # -------------------------------------------------------------------...
    void lvar_mapping_clear(lvar_mapping_t * map)  # -------------------------------------------------------------------...
    int lvar_mapping_size(lvar_mapping_t * map)  # -------------------------------------------------------------------...
    void lvar_mapping_free(lvar_mapping_t * map)  # -------------------------------------------------------------------...
    lvar_mapping_t * lvar_mapping_new()  # -------------------------------------------------------------------...
    void udcall_map_clear(udcall_map_t * map)  # -------------------------------------------------------------------...
    int udcall_map_size(udcall_map_t * map)  # -------------------------------------------------------------------...
    void udcall_map_free(udcall_map_t * map)  # -------------------------------------------------------------------...
    udcall_map_t * udcall_map_new()  # -------------------------------------------------------------------...
    void user_cmts_clear(user_cmts_t * map)  # -------------------------------------------------------------------...
    int user_cmts_size(user_cmts_t * map)  # -------------------------------------------------------------------...
    void user_cmts_free(user_cmts_t * map)  # -------------------------------------------------------------------...
    user_cmts_t * user_cmts_new()  # -------------------------------------------------------------------...
    void user_iflags_clear(user_iflags_t * map)  # -------------------------------------------------------------------...
    int user_iflags_size(user_iflags_t * map)  # -------------------------------------------------------------------...
    void user_iflags_free(user_iflags_t * map)  # -------------------------------------------------------------------...
    user_iflags_t * user_iflags_new()  # -------------------------------------------------------------------...
    void user_unions_clear(user_unions_t * map)  # -------------------------------------------------------------------...
    int user_unions_size(user_unions_t * map)  # -------------------------------------------------------------------...
    void user_unions_free(user_unions_t * map)  # -------------------------------------------------------------------...
    user_unions_t * user_unions_new()  # -------------------------------------------------------------------...
    void user_labels_clear(user_labels_t * map)  # -------------------------------------------------------------------...
    int user_labels_size(user_labels_t * map)  # -------------------------------------------------------------------...
    void user_labels_free(user_labels_t * map)  # -------------------------------------------------------------------...
    user_labels_t * user_labels_new()  # -------------------------------------------------------------------...
    void eamap_clear(eamap_t * map)  # -------------------------------------------------------------------...
    int eamap_size(eamap_t * map)  # -------------------------------------------------------------------...
    void eamap_free(eamap_t * map)  # -------------------------------------------------------------------...
    eamap_t * eamap_new()  # -------------------------------------------------------------------...
    void boundaries_clear(boundaries_t * map)  # -------------------------------------------------------------------...
    int boundaries_size(boundaries_t * map)  # -------------------------------------------------------------------...
    void boundaries_free(boundaries_t * map)  # -------------------------------------------------------------------...
    boundaries_t * boundaries_new()  # -------------------------------------------------------------------...
    void block_chains_clear(block_chains_t * set)  # -------------------------------------------------------------------...
    int block_chains_size(block_chains_t * set)  # -------------------------------------------------------------------...
    void block_chains_free(block_chains_t * set)  # -------------------------------------------------------------------...
    block_chains_t * block_chains_new()  # -------------------------------------------------------------------...
    void * hexrays_alloc(int size)  # -------------------------------------------------------------------...
    void hexrays_free(void * ptr)  # -------------------------------------------------------------------...
    bint must_mcode_close_block(mcode_t mcode, bint including_calls)  # Must an instruction with the given opcode be the last one in a bloc...
    bint is_mcode_propagatable(mcode_t mcode)  # May opcode be propagated? Such opcodes can be used in sub-instructi...
    mcode_t negate_mcode_relation(mcode_t code)  # Negate a conditional opcode. Conditional jumps can be negated, exam...
    mcode_t swap_mcode_relation(mcode_t code)  # Swap a conditional opcode. Only conditional jumps and set instructi...
    mcode_t get_signed_mcode(mcode_t code)  # Return the opcode that performs signed operation. Examples: jae -> ...
    mcode_t get_unsigned_mcode(mcode_t code)  # Return the opcode that performs unsigned operation. Examples: jl ->...
    bint mcode_modifies_d(mcode_t mcode)  # Does the 'd' operand gets modified by the instruction? Example: "ad...
    bint is_type_correct(const type_t * ptr)  # Verify a type string.
    bint arglocs_overlap(const vdloc_t & loc1, int w1, const vdloc_t & loc2, int w2)  # -------------------------------------------------------------------...
    bint restore_user_lvar_settings(lvar_uservec_t * lvinf, ea_t func_ea)  # Restore user defined local variable settings in the database.
    void save_user_lvar_settings(ea_t func_ea, const lvar_uservec_t & lvinf)  # Save user defined local variable settings into the database.
    bint modify_user_lvars(ea_t entry_ea, user_lvar_modifier_t & mlv)  # Modify saved local variable settings.
    bint modify_user_lvar_info(ea_t func_ea, uint mli_flags, const lvar_saved_info_t & info)  # Modify saved local variable settings of one variable.
    bint locate_lvar(lvar_locator_t * out, ea_t func_ea, const char * varname)  # Find a variable by name.
    bint restore_user_defined_calls(udcall_map_t * udcalls, ea_t func_ea)  # Restore user defined function calls from the database.
    void save_user_defined_calls(ea_t func_ea, const udcall_map_t & udcalls)  # Save user defined local function calls into the database.
    bint parse_user_call(udcall_t * udc, const char * decl, bint silent)  # Convert function type declaration into internal structure
    merror_t convert_to_user_call(const udcall_t & udc, codegen_t & cdg)  # try to generate user-defined call for an instruction
    bint install_microcode_filter(microcode_filter_t * filter, bint install)  # register/unregister non-standard microcode generator
    const mlist_t & get_temp_regs()  # -------------------------------------------------------------------...
    bint is_kreg(mreg_t r)  # Is a kernel register? Kernel registers are temporary registers that...
    mreg_t reg2mreg(int reg)  # Map a processor register to a microregister.
    int mreg2reg(mreg_t reg, int width)  # Map a microregister to a processor register.
    void install_optinsn_handler(optinsn_t * opt)  # Install an instruction level custom optimizer
    bint remove_optinsn_handler(optinsn_t * opt)  # Remove an instruction level custom optimizer
    void install_optblock_handler(optblock_t * opt)  # Install a block level custom optimizer.
    bint remove_optblock_handler(optblock_t * opt)  # Remove a block level custom optimizer
    const minsn_t * getf_reginsn(const minsn_t * ins)  # Skip assertions forward
    const minsn_t * getb_reginsn(const minsn_t * ins)  # Skip assertions backward
    bint change_hexrays_config(const char * directive)  # -------------------------------------------------------------------...
    const char * get_hexrays_version()  # -------------------------------------------------------------------...
    vdui_t * open_pseudocode(ea_t ea, int flags)  # Open pseudocode window. The specified function is decompiled and th...
    void send_database(const hexrays_failure_t & err, bint silent)  # Send the database to Hex-Rays. This function sends the current data...
    bint get_current_operand(gco_info_t * out)  # Get the instruction operand under the cursor. This function determi...
    void remitem(const citem_t * e)  # -------------------------------------------------------------------...
    ctype_t negated_relation(ctype_t op)  # Negate a comparison operator. For example, cot_sge becomes cot_slt
    ctype_t swapped_relation(ctype_t op)  # Swap a comparison operator. For example, cot_sge becomes cot_sle
    ctype_t asgop(ctype_t cop)  # Convert plain operator into assignment operator. For example, cot_a...
    ctype_t asgop_revert(ctype_t cop)  # Convert assignment operator into plain operator. For example, cot_a...
    cexpr_t * lnot(cexpr_t * e)  # Logically negate the specified expression. The specified expression...
    cinsn_t * new_block()  # Create a new block-statement.
    cexpr_t * make_ref(cexpr_t * e)  # Create a reference. This function performs the following conversion...
    cexpr_t * dereference(cexpr_t * e, int ptrsize, bint is_flt)  # Dereference a pointer. This function dereferences a pointer express...
    void save_user_labels(ea_t func_ea, const user_labels_t * user_labels, const cfunc_t * func)  # Save user defined labels into the database.
    void save_user_cmts(ea_t func_ea, const user_cmts_t * user_cmts)  # Save user defined comments into the database.
    void save_user_numforms(ea_t func_ea, const user_numforms_t * numforms)  # Save user defined number formats into the database.
    void save_user_iflags(ea_t func_ea, const user_iflags_t * iflags)  # Save user defined citem iflags into the database.
    void save_user_unions(ea_t func_ea, const user_unions_t * unions)  # Save user defined union field selections into the database.
    user_labels_t * restore_user_labels(ea_t func_ea, const cfunc_t * func)  # Restore user defined labels from the database.
    user_cmts_t * restore_user_cmts(ea_t func_ea)  # Restore user defined comments from the database.
    user_numforms_t * restore_user_numforms(ea_t func_ea)  # Restore user defined number formats from the database.
    user_iflags_t * restore_user_iflags(ea_t func_ea)  # Restore user defined citem iflags from the database.
    user_unions_t * restore_user_unions(ea_t func_ea)  # Restore user defined union field selections from the database.
    void close_hexrays_waitbox()  # Close the waitbox displayed by the decompiler. Useful if DECOMP_NO_...
    mba_t * gen_microcode(const mba_ranges_t & mbr, hexrays_failure_t * hf, const mlist_t * retlist, int decomp_flags, mba_maturity_t reqmat)  # Generate microcode of an arbitrary code snippet
    bint mark_cfunc_dirty(ea_t ea, bint close_views)  # Flush the cached decompilation results. Erases a cache entry for th...
    void clear_cached_cfuncs()  # Flush all cached decompilation results.
    bint has_cached_cfunc(ea_t ea)  # Do we have a cached decompilation result for 'ea'?
    const char * get_ctype_name(ctype_t op)  # -------------------------------------------------------------------...
