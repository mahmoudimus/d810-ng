# cython: language_level=3
# distutils: language=c++
#
# THIS FILE IS AUTO-GENERATED BY batch_pxdgen - DO NOT EDIT
# Generated: 2025-11-30 01:48:21
# Source: nalt.hpp
#

from libc.stdint cimport int16_t, int32_t, int64_t, int8_t, uint16_t, uint32_t, uint64_t, uint8_t
from libc.stddef cimport size_t
from libcpp cimport bool as cppbool

cdef extern from "nalt.hpp":
    ctypedef int64_t adiff_t
    ctypedef uint32_t bgcolor_t
    ctypedef uint64_t ea_t
    ctypedef uint64_t flags64_t
    ctypedef int16_t int16
    ctypedef int32_t int32
    ctypedef uint64_t nodeidx_t
    ctypedef int64_t ssize_t
    ctypedef int64_t sval_t
    ctypedef uint32_t tid_t
    ctypedef uint8_t uchar
    ctypedef uint32_t uint
    ctypedef uint32_t uint32
    ctypedef uint16_t ushort
    ctypedef uint64_t uval_t
    ctypedef uchar reftype_t
    ctypedef uchar type_t
    ctypedef uchar p_list
    cdef cppclass xrefpos_t:  # @{ Position of cursor in the window with cross-references to the ad...
        ea_t ea
        uchar type  # the type of xref (::cref_t & ::dref_t)
        xrefpos_t(ea_t ea_, uchar type_)
        bint is_valid() const
    cdef cppclass array_parameters_t:  # -------------------------------------------------------------------...
        int32 flags
        int32 lineitems  # number of items on a line
        int32 alignment  # -1 - don't align. 0 - align automatically. else item width
        array_parameters_t(int32 _f, int32 _l, int32 _a)
        bint is_default() const
    cdef cppclass switch_info_t:  # -------------------------------------------------------------------...
        uint32 flags  # SWI_
        ushort ncases  # number of cases (excluding default)
        ea_t jumps  # jump table start address
        ea_t values  # values table address (if #SWI_SPARSE is set)
        uval_t lowcase  # the lowest value in cases
        ea_t defjump  # default jump address (#BADADDR if no default case)
        ea_t startea  # start of the switch idiom
        int jcases  # number of entries in the jump table (SWI_INDIRECT)
        sval_t ind_lowcase
        ea_t elbase  # element base
        int regnum  # the switch expression as a value of the REGNUM register before the ...
        uval_t custom  # information for custom tables (filled and used by modules)
        int version
        ea_t expr_ea  # the address before that the switch expression is in REGNUM. If BADA...
        int get_shift() const  # See #SWI_SHIFT_MASK. possible answers: 0..3.
        void set_shift(int shift)  # See #SWI_SHIFT_MASK
        int get_jtable_element_size() const
        void set_jtable_element_size(int size)
        int get_vtable_element_size() const
        void set_vtable_element_size(int size)
        bint has_default() const
        bint has_elbase() const
        bint is_sparse() const
        bint is_custom() const
        bint is_indirect() const
        bint is_subtract() const
        bint is_nolowcase() const
        bint use_std_table() const
        bint is_user_defined() const
        sval_t get_lowcase() const
        int get_jtable_size() const
        void set_jtable_size(int size)
        void set_elbase(ea_t base)
        int get_version() const
        switch_info_t()
        void clear()
    cdef cppclass custom_data_type_ids_t:  # @{ Information about custom data types
        int16 dtid  # data type id
        void set(tid_t tid)
        tid_t get_dtid() const
    cdef cppclass refinfo_t:  # Information about a reference
        ea_t target  # reference target (#BADADDR-none)
        ea_t base  # base of reference (may be BADADDR)
        adiff_t tdelta  # offset from the target
        uint32 flags  # REFINFO_
        reftype_t type() const  # @}
        bint is_target_optional() const
        bint no_base_xref() const
        bint is_pastend() const
        bint is_rvaoff() const
        bint is_custom() const
        bint is_subtract() const
        bint is_signed() const
        bint is_no_zeros() const
        bint is_no_ones() const
        bint is_selfref() const
        void set_type(reftype_t rt)  # RT can include REFINFO_CUSTOM bit
        void init(uint32 reft_and_flags, ea_t _base, ea_t _target, adiff_t _tdelta)  # init the structure with some default values reft_and_flags should b...
    cdef cppclass custom_refinfo_handler_t:  # Manage a custom refinfo type Custom refinfos are usually used to ha...
        int32 cbsize  # size of this structure
        const char * name  # Format name, must be unique
        const char * desc  # Refinfo description to use in Ctrl-R dialog
        int props  # properties (currently 0)
    cdef cppclass refinfo_desc_t:  # Get descriptions of all standard and custom refinfo types.
        uint32 type  # Refinfo type, see REFINFO_ Custom refinfo has REFINFO_CUSTOM bit.
        const char * name  # Refinfo name
        const char * desc  # Refinfo description to use in Ctrl-R dialog
    cdef cppclass ida_movable_type:
        pass
    cdef cppclass strpath_t:  # Information for structure offsets. ids[0] contains the id of the st...
        int len
        adiff_t delta
    cdef cppclass enum_const_t:  # See opinfo_t::ec
        tid_t tid
        uchar serial
    cdef cppclass printop_t:  # -------------------------------------------------------------------...
        uint32 unused  # not used anymore, use flags64 instead (kept for backward compat)
        uchar features  # features this instance holds
        int suspop  # out: will be set by print_operand()
        flags64_t flags  # new operand representation flags
        printop_t()
        bint is_ti_initialized() const
        void set_ti_initialized(bint v)
        bint is_aflags_initialized() const
        void set_aflags_initialized(bint v)
        bint is_f64() const
    cdef cppclass tinfo_t
    nodeidx_t ea2node(ea_t ea)  # Get netnode for the specified address.
    ea_t node2ea(nodeidx_t ndx)
    nodeidx_t end_ea2node(ea_t ea)
    tid_t get_strid(ea_t ea)  # Returns the struct id of the struct type at the specified address. ...
    ssize_t get_xrefpos(xrefpos_t * out, ea_t ea)
    void set_xrefpos(ea_t ea, const xrefpos_t * in_)
    void del_xrefpos(ea_t ea)
    void del_aflags(ea_t ea)
    bint is_hidden_item(ea_t ea)
    void hide_item(ea_t ea)
    void unhide_item(ea_t ea)
    bint is_hidden_border(ea_t ea)
    void hide_border(ea_t ea)
    void unhide_border(ea_t ea)
    bint uses_modsp(ea_t ea)
    void set_usemodsp(ea_t ea)
    void clr_usemodsp(ea_t ea)
    bint is_zstroff(ea_t ea)
    void set_zstroff(ea_t ea)
    void clr_zstroff(ea_t ea)
    bint is__bnot0(ea_t ea)
    void set__bnot0(ea_t ea)
    void clr__bnot0(ea_t ea)
    bint is__bnot1(ea_t ea)
    void set__bnot1(ea_t ea)
    void clr__bnot1(ea_t ea)
    bint is_libitem(ea_t ea)
    void set_libitem(ea_t ea)
    void clr_libitem(ea_t ea)
    bint has_ti(ea_t ea)
    void set_has_ti(ea_t ea)
    void clr_has_ti(ea_t ea)
    bint has_ti0(ea_t ea)
    void set_has_ti0(ea_t ea)
    void clr_has_ti0(ea_t ea)
    bint has_ti1(ea_t ea)
    void set_has_ti1(ea_t ea)
    void clr_has_ti1(ea_t ea)
    bint has_lname(ea_t ea)
    void set_has_lname(ea_t ea)
    void clr_has_lname(ea_t ea)
    bint is_tilcmt(ea_t ea)
    void set_tilcmt(ea_t ea)
    void clr_tilcmt(ea_t ea)
    bint is_usersp(ea_t ea)
    void set_usersp(ea_t ea)
    void clr_usersp(ea_t ea)
    bint is_lzero0(ea_t ea)
    void set_lzero0(ea_t ea)
    void clr_lzero0(ea_t ea)
    bint is_lzero1(ea_t ea)
    void set_lzero1(ea_t ea)
    void clr_lzero1(ea_t ea)
    bint is_colored_item(ea_t ea)
    void set_colored_item(ea_t ea)
    void clr_colored_item(ea_t ea)
    bint is_terse_struc(ea_t ea)
    void set_terse_struc(ea_t ea)
    void clr_terse_struc(ea_t ea)
    bint is__invsign0(ea_t ea)
    void set__invsign0(ea_t ea)
    void clr__invsign0(ea_t ea)
    bint is__invsign1(ea_t ea)
    void set__invsign1(ea_t ea)
    void clr__invsign1(ea_t ea)
    bint is_noret(ea_t ea)
    void set_noret(ea_t ea)
    void clr_noret(ea_t ea)
    bint is_fixed_spd(ea_t ea)
    void set_fixed_spd(ea_t ea)
    void clr_fixed_spd(ea_t ea)
    bint is_align_flow(ea_t ea)
    void set_align_flow(ea_t ea)
    void clr_align_flow(ea_t ea)
    bint is_userti(ea_t ea)
    void set_userti(ea_t ea)
    void clr_userti(ea_t ea)
    bint is_retfp(ea_t ea)
    void set_retfp(ea_t ea)
    void clr_retfp(ea_t ea)
    bint is_notproc(ea_t ea)
    void set_notproc(ea_t ea)
    void clr_notproc(ea_t ea)
    bint is_type_guessed_by_ida(ea_t ea)
    bint is_func_guessed_by_hexrays(ea_t ea)
    bint is_data_guessed_by_hexrays(ea_t ea)
    bint is_type_determined_by_hexrays(ea_t ea)
    bint is_type_guessed_by_hexrays(ea_t ea)
    void set_type_guessed_by_ida(ea_t ea)
    void set_func_guessed_by_hexrays(ea_t ea)
    void set_data_guessed_by_hexrays(ea_t ea)
    void set_type_determined_by_hexrays(ea_t ea)
    void set_notcode(ea_t ea)  # Mark address so that it cannot be converted to instruction
    void clr_notcode(ea_t ea)  # Clear not-code mark
    bint is_notcode(ea_t ea)  # Is the address marked as not-code?
    void set_visible_item(ea_t ea, bint visible)  # Change visibility of item at given ea
    bint is_visible_item(ea_t ea)  # Test visibility of item at given ea
    bint is_finally_visible_item(ea_t ea)  # Is instruction visible?
    void set_source_linnum(ea_t ea, uval_t lnnum)  # They are sometimes present in object files. @{
    uval_t get_source_linnum(ea_t ea)
    void del_source_linnum(ea_t ea)
    ea_t get_absbase(ea_t ea)  # These functions may be used if necessary (despite of the AFLNOTE ab...
    void set_absbase(ea_t ea, ea_t x)
    void del_absbase(ea_t ea)
    ea_t get_ind_purged(ea_t ea)  # Number of bytes purged from the stack when a function is called ind...
    void set_ind_purged(ea_t ea, ea_t x)
    void del_ind_purged(ea_t ea)
    uint32 get_str_type(ea_t ea)  # Use higher level function get_opinfo(). @{
    void set_str_type(ea_t ea, uint32 x)
    void del_str_type(ea_t ea)
    uchar get_str_type_code(int32 strtype)  # See STRTYPE_ @{
    char get_str_term1(int32 strtype)
    char get_str_term2(int32 strtype)
    uchar get_str_encoding_idx(int32 strtype)  # if the second termination character is '\0', then it doesn't exist....
    int32 set_str_encoding_idx(int32 strtype, int encoding_idx)  # Set index of the string encoding in the string type
    int32 make_str_type(uchar type_code, int encoding_idx, uchar term1, uchar term2)  # Get string type for a string in the given encoding
    bint is_pascal(int32 strtype)
    int get_str_type_prefix_length(int32 strtype)
    uint32 get_alignment(ea_t ea)  # (should be power of 2) These functions may be used if necessary (de...
    void set_alignment(ea_t ea, uint32 x)
    void del_alignment(ea_t ea)
    void set_item_color(ea_t ea, bgcolor_t color)  # @{
    bgcolor_t get_item_color(ea_t ea)
    bint del_item_color(ea_t ea)
    ssize_t get_array_parameters(array_parameters_t * out, ea_t ea)
    void set_array_parameters(ea_t ea, const array_parameters_t * in_)
    void del_array_parameters(ea_t ea)
    ssize_t get_switch_info(switch_info_t * out, ea_t ea)  # See ::switch_info_t, xref.hpp for related functions @{
    void set_switch_info(ea_t ea, const switch_info_t & in_)
    void del_switch_info(ea_t ea)
    ea_t get_switch_parent(ea_t ea)  # Address which holds the switch info (::switch_info_t). Used at the ...
    void set_switch_parent(ea_t ea, ea_t x)
    void del_switch_parent(ea_t ea)
    int get_custom_data_type_ids(custom_data_type_ids_t * cdis, ea_t ea)
    void set_custom_data_type_ids(ea_t ea, const custom_data_type_ids_t * cdis)
    void del_custom_data_type_ids(ea_t ea)
    bint is_reftype_target_optional(reftype_t type)  # Can the target be calculated using operand value?
    reftype_t get_reftype_by_size(int size)  # Get REF_... constant from size Supported sizes: 1,2,4,8,16 For othe...
    bint unregister_custom_refinfo(int crid)  # Unregister a new custom refinfo type.
    int find_custom_refinfo(const char * name)  # Get id of a custom refinfo type.
    bint is_reftype_target_optional(reftype_t type)  # Can the target be calculated using operand value?
    bint set_refinfo_ex(ea_t ea, int n, const refinfo_t * ri)  # n may be 0, 1, 2, #OPND_MASK. #OPND_OUTER may be used too. Don't us...
    bint set_refinfo(ea_t ea, int n, reftype_t type, ea_t target, ea_t base, adiff_t tdelta)
    bint get_refinfo(refinfo_t * ri, ea_t ea, int n)
    bint del_refinfo(ea_t ea, int n)
    void write_struc_path(ea_t ea, int idx, const tid_t * path, int plen, adiff_t delta)  # -------------------------------------------------------------------...
    int read_struc_path(tid_t * path, adiff_t * delta, ea_t ea, int idx)
    bint get_tinfo(tinfo_t * tif, ea_t ea)  # Work with function/data types These functions may be used if necess...
    bint set_tinfo(ea_t ea, const tinfo_t * tif)
    void del_tinfo(ea_t ea)
    bint get_op_tinfo(tinfo_t * tif, ea_t ea, int n)  # These functions may be used if necessary (despite of the AFLNOTE ab...
    bint set_op_tinfo(ea_t ea, int n, const tinfo_t * tif)
    void del_op_tinfo(ea_t ea, int n)
    ssize_t get_root_filename(char * buf, int bufsize)  # -------------------------------------------------------------------...
    ssize_t dbg_get_input_path(char * buf, int bufsize)  # Get debugger input file name/path (see #LFLG_DBG_NOPATH)
    ssize_t get_input_file_path(char * buf, int bufsize)  # Get full path of the input file
    void set_root_filename(const char * file)  # Set full path of the input file
    int retrieve_input_file_size()  # Get size of input file in bytes
    uint32 retrieve_input_file_crc32()  # Get input file crc32 stored in the database. it can be used to chec...
    bint set_asm_inc_file(const char * file)  # Set name of the include file
    ea_t get_imagebase()  # Get image base address
    void set_imagebase(ea_t base)  # Set image base address
    bint set_archive_path(const char * file)  # Set archive file path from which input file was extracted
    void set_loader_format_name(const char * name)  # Set file format name for loader modules
    void set_ida_notepad_text(const char * text, int size)  # Set notepad text
    void set_srcdbg_paths(const char * paths)  # Set source debug paths
    void set_srcdbg_undesired_paths(const char * paths)  # Set user-closed source files
    ushort get_initial_idb_version()  # Get initial version of the database (numeric format like 700)
    int get_elapsed_secs()  # Get seconds database stayed open
    int get_idb_nopens()  # Get number of times the database is opened
    int get_encoding_qty()  # Get total number of encodings (counted from 0)
    const char * get_encoding_name(int idx)  # Get encoding name for specific index (1-based).
    int add_encoding(const char * encname)  # Add a new encoding (e.g. "UTF-8"). If it's already in the list, ret...
    bint del_encoding(int idx)  # Delete an encoding The encoding is not actually removed because its...
    bint rename_encoding(int idx, const char * encname)  # Change name for an encoding The number of bytes per unit (BPU) of t...
    int get_encoding_bpu(int idx)  # Get the amount of bytes per unit (e.g., 2 for UTF-16, 4 for UTF-32)...
    int get_encoding_bpu_by_name(const char * encname)  # Get the amount of bytes per unit for the given encoding
    int get_strtype_bpu(int32 strtype)  # -------------------------------------------------------------------...
    int get_default_encoding_idx(int bpu)  # Get default encoding index for a specific string type.
    bint set_default_encoding_idx(int bpu, int idx)  # Set default encoding for a string type
    const char * encoding_from_strtype(int32 strtype)  # Get encoding name for this strtype
    int get_outfile_encoding_idx()  # Get the index of the encoding used when producing files
    bint set_outfile_encoding_idx(int idx)  # set encoding to be used when producing files
    uint get_import_module_qty()  # Get number of import modules
    void delete_imports()  # Delete all imported modules information
    int validate_idb_names(bint do_repair)  # Check consistency of name records, return number of bad ones
    void set_gotea(ea_t gotea)  # -------------------------------------------------------------------...
    ea_t get_gotea()  # -------------------------------------------------------------------...
