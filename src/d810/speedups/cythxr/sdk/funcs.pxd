# cython: language_level=3
# distutils: language=c++
#
# THIS FILE IS AUTO-GENERATED BY batch_pxdgen - DO NOT EDIT
# Generated: 2025-11-30 01:47:25
# Source: funcs.hpp
#

from libc.stdint cimport int16_t, int32_t, int64_t, int8_t, uint16_t, uint32_t, uint64_t, uint8_t
from libc.stddef cimport size_t
from libcpp cimport bool as cppbool

cdef extern from "funcs.hpp":
    ctypedef uint64_t asize_t
    ctypedef uint32_t bgcolor_t
    ctypedef uint64_t ea_t
    ctypedef uint64_t flags64_t
    ctypedef int32_t int32
    ctypedef int64_t ssize_t
    ctypedef uint8_t type_t
    ctypedef uint32_t uint32
    ctypedef uint64_t uint64
    ctypedef uint16_t ushort
    ctypedef uint64_t uval_t
    cdef cppclass stkpnt_t
    cdef cppclass regvar_t
    cdef cppclass llabel_t
    cdef cppclass insn_t
    cdef cppclass regarg_t:  # Register argument description. regargs are destroyed when the full ...
        int reg
        type_t * type
        char * name
        regarg_t()
        regarg_t(const regarg_t & r)
        regarg_t & operator=(const regarg_t & r)
        void swap(regarg_t & r)
    cdef cppclass ida_movable_type:
        pass
    cdef cppclass func_t:  # -------------------------------------------------------------------...
        uint64 flags  # FUNC_
        uval_t frame  # netnode id of frame structure - see frame.hpp
        asize_t frsize  # size of local variables part of frame in bytes. If #FUNC_FRAME is s...
        ushort frregs  # size of saved registers in frame. This range is immediately above t...
        asize_t argsize  # number of bytes purged from the stack upon returning
        asize_t fpd  # frame pointer delta. (usually 0, i.e. realBP==typicalBP) use update...
        bgcolor_t color  # user defined function color
        uint32 pntqty  # number of SP change points
        stkpnt_t * points  # array of SP change points. use ...stkpnt...() functions to access t...
        int regvarqty  # number of register variables (-1-not read in yet) use find_regvar()...
        regvar_t * regvars  # array of register variables. this array is sorted by: start_ea. use...
        int llabelqty  # number of local labels
        llabel_t * llabels  # local labels array. this array shouldn't be modified directly; name...
        int regargqty  # number of register arguments. During analysis IDA tries to guess th...
        regarg_t * regargs  # unsorted array of register arguments. use ...regarg...() functions ...
        int tailqty  # number of function tails
        ea_t owner  # the address of the main function possessing this tail
        int refqty  # number of referers
        ea_t * referers  # array of referers (function start addresses). use func_parent_itera...
        bint is_far() const  # Is a far function?
        bint does_return() const  # Does function return?
        bint analyzed_sp() const  # Has SP-analysis been performed?
        bint need_prolog_analysis() const  # Needs prolog analysis?
        func_t(ea_t start, ea_t end, flags64_t f)
    cdef cppclass lock_func:  # Helper class to lock a function pointer so it stays valid
        lock_func(const func_t * _pfn)
    cdef cppclass lock_func_with_tails_t:  # lint -esym(1788, lock_func_with_tails_t) referenced only by ctr/dtr
        lock_func_with_tails_t(func_t * pfn)  # @}
    cdef cppclass func_tail_iterator_t:  # Class to enumerate all function tails sorted by addresses. Enumerat...
        func_tail_iterator_t()
        func_tail_iterator_t(func_t * _pfn, ea_t ea)
        bint set(func_t * _pfn, ea_t ea)
        bint set_ea(ea_t ea)
        bint set_range(ea_t ea1, ea_t ea2)  # set an arbitrary range
        bint first()
        bint last()
        bint next()
        bint prev()
        bint main()
    cdef cppclass func_item_iterator_t:  # Class to enumerate all function instructions and data sorted by add...
        func_item_iterator_t()
        func_item_iterator_t(func_t * pfn, ea_t _ea)
        bint set(func_t * pfn, ea_t _ea)  # Set a function range. if pfn == nullptr then a segment range will b...
        bint set_range(ea_t ea1, ea_t ea2)  # Set an arbitrary range
        bint first()
        bint last()
        ea_t current() const
        bint set_ea(ea_t _ea)
        bint next_addr()
        bint next_head()
        bint next_code()
        bint next_data()
        bint next_not_tail()
        bint prev_addr()
        bint prev_head()
        bint prev_code()
        bint prev_data()
        bint prev_not_tail()
        bint decode_prev_insn(insn_t * out)
        bint succ_code()
    cdef cppclass func_parent_iterator_t:  # Auxiliary function(s) to be used in func_..._iterator_t
        func_parent_iterator_t()
        func_parent_iterator_t(func_t * _fnt)
        bint set(func_t * _fnt)
        ea_t parent() const
        bint first()
        bint last()
        bint next()
        bint prev()
        void reset_fnt(func_t * _fnt)
    void free_regarg(regarg_t * v)
    bint is_func_entry(const func_t * pfn)  # Does function describe a function entry chunk?
    bint is_func_tail(const func_t * pfn)  # Does function describe a function tail chunk?
    void lock_func_range(const func_t * pfn, bint lock)  # Lock function pointer Locked pointers are guaranteed to remain vali...
    bint is_func_locked(const func_t * pfn)  # Is the function pointer locked?
    func_t * get_func(ea_t ea)  # -------------------------------------------------------------------...
    int get_func_chunknum(func_t * pfn, ea_t ea)  # Get the containing tail chunk of 'ea'.
    bint func_contains(func_t * pfn, ea_t ea)  # Does the given function contain the given address?
    bint is_same_func(ea_t ea1, ea_t ea2)  # Do two addresses belong to the same function?
    func_t * getn_func(int n)  # Get pointer to function structure by number.
    int get_func_qty()  # Get total number of functions in the program
    int get_func_num(ea_t ea)  # Get ordinal number of a function.
    func_t * get_prev_func(ea_t ea)  # Get pointer to the previous function.
    func_t * get_next_func(ea_t ea)  # Get pointer to the next function.
    bint set_func_cmt(const func_t * pfn, const char * cmt, bint repeatable)  # Set function comment. This function works with function chunks too.
    bint update_func(func_t * pfn)  # Update information about a function in the database (::func_t). You...
    bint add_func_ex(func_t * pfn)  # Add a new function. If the fn->end_ea is #BADADDR, then IDA will tr...
    bint add_func(ea_t ea1, ea_t ea2)  # Add a new function. If the function end address is #BADADDR, then I...
    bint del_func(ea_t ea)  # Delete a function.
    int set_func_start(ea_t ea, ea_t newstart)  # Move function chunk start address.
    bint set_func_end(ea_t ea, ea_t newend)  # Move function chunk end address.
    void reanalyze_function(func_t * pfn, ea_t ea1, ea_t ea2, bint analyze_parents)  # Reanalyze a function. This function plans to analyzes all chunks of...
    int find_func_bounds(func_t * nfn, int flags)  # Determine the boundaries of a new function. This function tries to ...
    asize_t calc_func_size(func_t * pfn)  # Calculate function size. This function takes into account all fragm...
    int get_func_bitness(const func_t * pfn)  # Get function bitness (which is equal to the function segment bitnes...
    int get_func_bits(const func_t * pfn)  # Get number of bits in the function addressing
    int get_func_bytes(const func_t * pfn)  # Get number of bytes in the function addressing
    bint is_visible_func(func_t * pfn)  # Is the function visible (not hidden)?
    bint is_finally_visible_func(func_t * pfn)  # Is the function visible (event after considering #SCF_SHHID_FUNC)?
    void set_visible_func(func_t * pfn, bint visible)  # Set visibility of function
    int set_func_name_if_jumpfunc(func_t * pfn, const char * oldname)  # Give a meaningful name to function if it consists of only 'jump' in...
    ea_t calc_thunk_func_target(func_t * pfn, ea_t * fptr)  # Calculate target of a thunk function.
    bint func_does_return(ea_t callee)  # Does the function return?. To calculate the answer, #FUNC_NORET fla...
    bint reanalyze_noret_flag(ea_t ea)  # Plan to reanalyze noret flag. This function does not remove FUNC_NO...
    bint set_noret_insn(ea_t insn_ea, bint noret)  # Signal a non-returning instruction. This function can be used by th...
    func_t * get_fchunk(ea_t ea)  # -------------------------------------------------------------------...
    func_t * getn_fchunk(int n)  # Get pointer to function chunk structure by number.
    int get_fchunk_qty()  # Get total number of function chunks in the program
    int get_fchunk_num(ea_t ea)  # Get ordinal number of a function chunk in the global list of functi...
    func_t * get_prev_fchunk(ea_t ea)  # Get pointer to the previous function chunk in the global list.
    func_t * get_next_fchunk(ea_t ea)  # Get pointer to the next function chunk in the global list.
    bint append_func_tail(func_t * pfn, ea_t ea1, ea_t ea2)  # Append a new tail chunk to the function definition. If the tail alr...
    bint remove_func_tail(func_t * pfn, ea_t tail_ea)  # Remove a function tail. If the tail belongs only to one function, i...
    bint set_tail_owner(func_t * fnt, ea_t new_owner)  # Set a new owner of a function tail. The new owner function must be ...
    bint f_any(flags64_t arg38, void * arg49)  # Helper function to accept any address
    ea_t get_prev_func_addr(func_t * pfn, ea_t ea)  # Unlike func_item_iterator_t which always enumerates the main functi...
    ea_t get_next_func_addr(func_t * pfn, ea_t ea)
    void read_regargs(func_t * pfn)  # -------------------------------------------------------------------...
    int plan_to_apply_idasgn(const char * fname)  # Add a signature file to the list of planned signature files.
    int apply_idasgn_to(const char * signame, ea_t ea, bint is_startup)  # Apply a signature file to the specified address.
    int get_idasgn_qty()  # Get number of signatures in the list of planned and applied signatu...
    int get_current_idasgn()  # Get number of the the current signature.
    int calc_idasgn_state(int n)  # Get state of a signature in the list of planned signatures
    int del_idasgn(int n)  # Remove signature from the list of planned signatures.
    void determine_rtl()  # Determine compiler/vendor using the startup signatures. If determin...
    bint apply_startup_sig(ea_t ea, const char * startup)  # Apply a startup signature file to the specified address.
    int try_to_add_libfunc(ea_t ea)  # Apply the currently loaded signature file to the specified address....
