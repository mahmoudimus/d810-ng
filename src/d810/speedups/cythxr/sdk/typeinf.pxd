# cython: language_level=3
# distutils: language=c++
#
# THIS FILE IS AUTO-GENERATED BY batch_pxdgen - DO NOT EDIT
# Generated: 2025-11-30 01:48:34
# Source: typeinf.hpp
#

from libc.stdint cimport int16_t, int32_t, int64_t, int8_t, uint16_t, uint32_t, uint64_t, uint8_t
from libc.stddef cimport size_t
from libcpp cimport bool as cppbool

cdef extern from "typeinf.hpp":
    ctypedef int64_t adiff_t
    ctypedef uint64_t asize_t
    ctypedef uint8_t cm_t
    ctypedef uint8_t comp_t
    ctypedef uint64_t ea_t
    ctypedef uint64_t flags64_t
    ctypedef int16_t int16
    ctypedef int32_t int32
    ctypedef uint8_t op_t
    ctypedef int64_t ssize_t
    ctypedef int64_t sval_t
    ctypedef uint32_t tid_t
    ctypedef uint8_t uchar
    ctypedef uint32_t uint
    ctypedef uint16_t uint16
    ctypedef uint32_t uint32
    ctypedef uint64_t uint64
    ctypedef uint16_t ushort
    ctypedef uint64_t uval_t
    ctypedef uchar type_t
    ctypedef uchar p_string
    ctypedef uchar p_list
    ctypedef uint64 bmask64_t
    ctypedef uchar bte_t
    ctypedef int type_sign_t
    ctypedef int argloc_type_t
    ctypedef uint64 typid_t
    cdef enum argreg_policy_t:  # -------------------------------------------------------------------...
        ARGREGS_POLICY_UNDEFINED = 0
        ARGREGS_GP_ONLY = 1  # GP registers used for all arguments
        ARGREGS_INDEPENDENT = 2  # FP/GP registers used separately (like gcc64)
        ARGREGS_BY_SLOTS = 3  # fixed FP/GP register per each slot (like vc64)
        ARGREGS_FP_MASKS_GP = 4  # FP register also consumes one or more GP regs but not vice versa (a...
        ARGREGS_MIPS_O32 = 5  # MIPS ABI o32
        ARGREGS_RISCV = 6  # Risc-V API FP arguments are passed in GP registers if FP registers ...
    cdef enum abs_t:  # -------------------------------------------------------------------...
        ABS_UNK = 0
        ABS_NO = 1
        ABS_YES = 2
    cdef enum sclass_t:
        SC_UNK = 0  # unknown
        SC_TYPE = 1  # typedef
        SC_EXT = 2  # extern
        SC_STAT = 3  # static
        SC_REG = 4  # register
        SC_AUTO = 5  # auto
        SC_FRIEND = 6  # friend
        SC_VIRT = 7  # virtual
    cdef enum tinfo_code_t:  # Error codes various tinfo functions:
        TERR_OK = 0  # ok
        TERR_SAVE_ERROR = -1  # failed to save
        TERR_SERIALIZE = -2  # failed to serialize
        TERR_BAD_NAME = -3  # name %s is not acceptable
        TERR_BAD_ARG = -4  # bad argument
        TERR_BAD_TYPE = -5  # bad type
        TERR_BAD_SIZE = -6  # bad size %d
        TERR_BAD_INDEX = -7  # bad index %d
        TERR_BAD_ARRAY = -8  # arrays are forbidden as function arguments
        TERR_BAD_BF = -9  # bitfields are forbidden as function arguments
        TERR_BAD_OFFSET = -10  # bad member offset %s
        TERR_BAD_UNIVAR = -11  # unions cannot have variable sized members
        TERR_BAD_VARLAST = -12  # variable sized member must be the last member in the structure
        TERR_OVERLAP = -13  # the member overlaps with other members that cannot be deleted
        TERR_BAD_SUBTYPE = -14  # recursive structure nesting is forbidden
        TERR_BAD_VALUE = -15  # value 0x%I64X is not acceptable
        TERR_NO_BMASK = -16  # bitmask 0x%I64X is not found
        TERR_BAD_BMASK = -17  # Bad enum member mask 0x%I64X. The specified mask should not interse...
        TERR_BAD_MSKVAL = -18  # bad bmask and value combination (value=0x%I64X; bitmask 0x%I64X)
        TERR_BAD_REPR = -19  # bad or incompatible field representation
        TERR_GRP_NOEMPTY = -20  # could not delete group mask for not empty group 0x%I64X
        TERR_DUPNAME = -21  # duplicate name %s
        TERR_UNION_BF = -22  # unions cannot have bitfields
        TERR_BAD_TAH = -23  # bad bits in the type attributes (TAH bits)
        TERR_BAD_BASE = -24  # bad base class
        TERR_BAD_GAP = -25  # bad gap
        TERR_NESTED = -26  # recursive structure nesting is forbidden
        TERR_NOT_COMPAT = -27  # the new type is not compatible with the old type
        TERR_BAD_LAYOUT = -28  # failed to calculate the structure/union layout
        TERR_BAD_GROUPS = -29  # bad group sizes for bitmask enum
        TERR_BAD_SERIAL = -30  # enum value has too many serials
        TERR_ALIEN_NAME = -31  # enum member name is used in another enum
        TERR_STOCK = -32  # stock type info cannot be modified
        TERR_ENUM_SIZE = -33  # bad enum size
        TERR_NOT_IMPL = -34  # not implemented
        TERR_TYPE_WORSE = -35  # the new type is worse than the old type
        TERR_BAD_FX_SIZE = -36  # cannot extend struct beyond fixed size
        TERR_STRUCT_SIZE = -37  # bad fixed structure size
        TERR_NOT_FOUND = -38  # member not found
        TERR_COUNT = 39
    cdef enum stock_type_id_t:  # IDs for common types
        STI_PCHAR = 0  # char *
        STI_PUCHAR = 1  # uint8 *
        STI_PCCHAR = 2  # const char *
        STI_PCUCHAR = 3  # const uint8 *
        STI_PBYTE = 4  # _BYTE *
        STI_PINT = 5  # int *
        STI_PUINT = 6  # unsigned int *
        STI_PVOID = 7  # void *
        STI_PPVOID = 8  # void **
        STI_PCVOID = 9  # const void *
        STI_ACHAR = 10  # char[]
        STI_AUCHAR = 11  # uint8[]
        STI_ACCHAR = 12  # const char[]
        STI_ACUCHAR = 13  # const uint8[]
        STI_FPURGING = 14  # void __userpurge(int)
        STI_FDELOP = 15  # void __cdecl(void *)
        STI_MSGSEND = 16  # void *(void *, const char *, ...)
        STI_AEABI_LCMP = 17  # int __fastcall __pure(int64 x, int64 y)
        STI_AEABI_ULCMP = 18  # int __fastcall __pure(uint64 x, uint64 y)
        STI_DONT_USE = 19  # unused stock type id; should not be used
        STI_SIZE_T = 20  # size_t
        STI_SSIZE_T = 21  # ssize_t
        STI_AEABI_MEMCPY = 22  # void __fastcall(void *, const void *, size_t)
        STI_AEABI_MEMSET = 23  # void __fastcall(void *, size_t, int)
        STI_AEABI_MEMCLR = 24  # void __fastcall(void *, size_t)
        STI_RTC_CHECK_2 = 25  # int16 __fastcall(int16 x)
        STI_RTC_CHECK_4 = 26  # int32 __fastcall(int32 x)
        STI_RTC_CHECK_8 = 27  # int64 __fastcall(int64 x)
        STI_COMPLEX64 = 28  # struct complex64_t { float real, imag; }
        STI_COMPLEX128 = 29  # struct complex128_t { double real, imag; }
        STI_PUNKNOWN = 30  # _UNKNOWN *
        STI_LAST = 31
    cdef enum etf_flag_t:  # Constants to be used the editing methods @{
        ETF_NO_SAVE = 1  # don't save to til (normally typerefs are saved to til) A call with ...
        ETF_NO_LAYOUT = 2  # don't calc type layout before editing
        ETF_MAY_DESTROY = 4  # may destroy other members
        ETF_COMPATIBLE = 8  # new type must be compatible with the old
        ETF_FUNCARG = 16  # udm - member is a function argument (cannot create arrays)
        ETF_FORCENAME = 32  # anyway use name, see below for more usage description
        ETF_AUTONAME = 64  # udm - generate a member name if was not specified (add_udm, set_udm...
        ETF_BYTIL = 128  # udm - new type was created by the type subsystem
        ETF_NO_ARRAY = 256  # add_udm, set_udm_type - do not convert type to an array on the size...
    cdef enum gtd_udt_t:  # Constants to be used with get_udt_details()
        GTD_CALC_LAYOUT = 0  # calculate udt layout
        GTD_NO_LAYOUT = 128  # don't calculate udt layout please note that udt layout may have bee...
        GTD_DEL_BITFLDS = 64  # delete udt bitfields
    cdef enum gtd_func_t:  # Constants to be used with get_func_details()
        GTD_CALC_ARGLOCS = 0  # calculate func arg locations
        GTD_NO_ARGLOCS = 128  # don't calculate func arg locations please note that the locations m...
    cdef enum gts_code_t:  # Constants to be used with get_size()
        GTS_NESTED = 1  # nested type (embedded into a udt)
        GTS_BASECLASS = 2  # is baseclass of a udt
    cdef enum format_functype_t:  # -------------------------------------------------------------------...
        FMTFUNC_PRINTF = 0
        FMTFUNC_SCANF = 1
        FMTFUNC_STRFTIME = 2
        FMTFUNC_STRFMON = 3
    cdef enum update_type_t:  # See begin_type_updating()
        UTP_ENUM = 0
        UTP_STRUCT = 1
    cdef cppclass lexer_t
    cdef cppclass func_t
    cdef cppclass til_bucket_t
    cdef cppclass til_stream_t
    cdef cppclass tinfo_changes_t
    cdef cppclass type_attr_t:  # @{ Extended type attributes.
        bint operator<(const type_attr_t & r) const
        bint operator>=(const type_attr_t & r) const
    cdef cppclass ida_movable_type:
        pass
    cdef cppclass til_t:  # -------------------------------------------------------------------...
        char * name  # short file name (without path and extension)
        char * desc  # human readable til description
        int nbases  # number of base tils
        til_t ** base  # tils that our til is based on
        uint32 flags  # TIL_
        til_bucket_t * syms  # symbols
        til_bucket_t * types  # types
        til_bucket_t * macros  # macros
        int nrefs  # number of references to the til
        int nstreams  # number of extra streams
        til_stream_t ** streams  # symbol stream storage
        bint is_dirty() const  # @} Has the til been modified? (#TIL_MOD)
        void set_dirty()  # Mark the til as modified (#TIL_MOD)
        til_t * find_base(const char * n)  # Find the base til with the provided name
    cdef cppclass rrel_t:  # Register-relative argument location
        sval_t off  # displacement from the address pointed by the register
        int reg  # register index (into {ph,processor_t,reg_names})
    cdef cppclass custloc_desc_t:  # Description of a custom argloc. Custom arglocs can be added by plug...
        int cbsize  # size of this structure
        const char * name  # name of the custom argloc type. must be unique
    cdef cppclass argloc_t:  # Describes an argument location. A typical argument is stored in one...
        argloc_t()
        argloc_t(const argloc_t & r)
        argloc_t & operator=(const argloc_t & r)
        void swap(argloc_t & r)  # Assign this == r and r == this
        const char * dstr() const
        argloc_type_t atype() const
        bint is_reg1() const
        bint is_reg2() const
        bint is_reg() const
        bint is_rrel() const
        bint is_ea() const
        bint is_stkoff() const
        bint is_scattered() const
        bint has_reg() const
        bint has_stkoff() const
        bint is_mixed_scattered() const
        bint in_stack() const
        bint is_fragmented() const
        bint is_custom() const
        bint is_badloc() const
        int reg1() const  # Get the register info. Use when atype() == ::ALOC_REG1 or ::ALOC_REG2
        int regoff() const  # Get offset from the beginning of the register in bytes. Use when at...
        int reg2() const  # Get info for the second register. Use when atype() == ::ALOC_REG2
        uint32 get_reginfo() const  # Get all register info. Use when atype() == ::ALOC_REG1 or ::ALOC_REG2
        sval_t stkoff() const  # Get the stack offset. Use if atype() == ::ALOC_STACK
        ea_t get_ea() const  # Get the global address. Use when atype() == ::ALOC_STATIC
        scattered_aloc_t & scattered()  # Get scattered argument info. Use when atype() == ::ALOC_DIST
        const scattered_aloc_t & scattered() const
        rrel_t & get_rrel()  # Get register-relative info. Use when atype() == ::ALOC_RREL
        const rrel_t & get_rrel() const
        void * get_custom() const  # Get custom argloc info. Use if atype() == ::ALOC_CUSTOM
        void _set_badloc()  # be careful with these functions, they do not cleanup!
        void _set_reg1(int reg, int off)
        void _set_reg2(int _reg1, int _reg2)
        void _set_stkoff(sval_t off)
        void _set_ea(ea_t _ea)
        bint _consume_rrel(rrel_t * p)  # Use consume_rrel()
        bint _consume_scattered(scattered_aloc_t * p)  # Use consume_scattered()
        void _set_custom(argloc_type_t ct, void * pdata)  # Set custom argument location (careful - this function does not clea...
        void set_reg1(int reg, int off)  # Set register location
        void set_reg2(int _reg1, int _reg2)  # Set secondary register location
        void set_stkoff(sval_t off)  # Set stack offset location
        void set_ea(ea_t _ea)  # Set static ea location
        void consume_rrel(rrel_t * p)  # Set register-relative location - can't be nullptr
        void consume_scattered(scattered_aloc_t * p)  # Set distributed argument location
        void set_badloc()  # Set to invalid location
        sval_t calc_offset() const  # Calculate offset that can be used to compare 2 similar arglocs
        bint advance(int delta)  # Move the location to point 'delta' bytes further
        void align_reg_high(int size, int _slotsize)  # Set register offset to align it to the upper part of _SLOTSIZE
        void align_stkoff_high(int size, int _slotsize)  # Set stack offset to align to the upper part of _SLOTSIZE
        bint operator==(const argloc_t & r) const
        bint operator!=(const argloc_t & r) const
        bint operator<(const argloc_t & r) const
        bint operator>(const argloc_t & r) const
        bint operator<=(const argloc_t & r) const
        bint operator>=(const argloc_t & r) const
        int compare(const argloc_t & r) const
    cdef cppclass argpart_t(argloc_t):  # Subsection of an argument location
        ushort off  # offset from the beginning of the argument
        ushort size  # the number of bytes
        argpart_t(const argloc_t & a)
        argpart_t()
        argpart_t & copy_from(const argloc_t & a)
        bint bad_offset() const  # Does this argpart have a valid offset?
        bint bad_size() const  # Does this argpart have a valid size?
        bint operator<(const argpart_t & r) const  # Compare two argparts, based on their offset
        void swap(argpart_t & r)  # Assign this = r and r = this
    cdef cppclass scattered_aloc_t:  # Used to manage arguments that are described by multiple locations (...
        pass
    cdef cppclass aloc_visitor_t:  # Visit all argument locations. The callback will not receive ::ALOC_...
        int visit_location(argloc_t & v, int off, int size)
    cdef cppclass const_aloc_visitor_t:  # Same as ::aloc_visitor_t, but may not modify the argloc
        int visit_location(const argloc_t & v, int off, int size)
    cdef cppclass stkarg_area_info_t:
        int cb
        sval_t stkarg_offset  # Offset from the SP to the first stack argument (can include linkage...
        sval_t shadow_size  # Size of the shadow area. explanations at: https://stackoverflow.com...
        sval_t linkage_area  # Size of the linkage area. explanations at: https://www.ibm.com/docs...
        stkarg_area_info_t()
    cdef cppclass custom_callcnv_t:  # -------------------------------------------------------------------...
        int cbsize
        uint64 flags
        uint32 abibits  # abibits to be used for the calling convention
        bint is_vararg() const
        bint is_purging() const
        bint is_usercall() const
        bint calc_retloc(func_type_data_t * fti) const  # Calculate the location of the return value. This function must fill...
        bint calc_arglocs(func_type_data_t * fti) const  # Calculate the argument locations. This function must fill all fti->...
        bint get_cc_regs(callregs_t * out) const  # Retrieve generic information about call registers
        bint get_stkarg_area_info(stkarg_area_info_t * out) const  # Retrieve generic information about stack arguments
        int calc_purged_bytes(const func_type_data_t & fti, ea_t call_ea) const  # Calculate the number of purged bytes
        int lower_func_type(func_type_data_t * fti) const  # Lower a function type. See lower_type() for more explanations.
        custom_callcnv_t()
        custom_callcnv_t(const char * _name, uint64 f, uint32 _abibits)
    cdef cppclass callregs_t:  # Register allocation calling convention. (allocation policy, arrays ...
        argreg_policy_t policy  # argument policy
        int nregs  # max number of registers that can be used in a call
        callregs_t()  # Constructor
        void swap(callregs_t & r)  # swap two instances
        bint by_slots() const  # policy-specific options
        void set(argreg_policy_t _policy, const int * gprs, const int * fprs)  # Init policy & registers (arrays are -1-terminated)
        void reset()  # Set policy and registers to invalid values
        bint reginds(int * gp_ind, int * fp_ind, int r) const  # Get register indexes within GP/FP arrays. (-1 -> is not present in ...
    cdef cppclass tinfo_t:  # Primary mechanism for managing type information
        tinfo_t()  # Constructor
        tinfo_t(type_t decl_type)  # Constructor - can only be used to initialize simple types!
        tinfo_t(const char * decl, til_t * til, int pt_flags)  # Constructor - will attempt to parse the provided C declaration
        tinfo_t(const tinfo_t & r)  # Constructor
        tinfo_t & operator=(const tinfo_t & r)  # Copy contents of given tinfo into this one
        void clear()  # Clear contents of this tinfo, and remove from the type system
        void swap(tinfo_t & r)  # Assign this = r and r = this
        bint get_named_type(const til_t * til, const char * name, type_t decl_type, bint resolve, bint try_ordinal)  # Create a tinfo_t object for an existing named type.
        bint get_named_type(const char * name, type_t decl_type, bint resolve, bint try_ordinal)
        bint get_numbered_type(const til_t * til, uint32 ordinal, type_t decl_type, bint resolve)  # Create a tinfo_t object for an existing ordinal type.
        bint get_numbered_type(uint32 ordinal, type_t decl_type, bint resolve)
        bint detach()  # Detach tinfo_t from the underlying type. After calling this finctio...
        bint deserialize(const til_t * til, const type_t ** ptype, const p_list ** pfields, const p_list ** pfldcmts, const char * cmt)  # Deserialize a type string into a tinfo_t object
        bint is_correct() const  # Is the type object correct?. It is possible to create incorrect typ...
        type_t get_realtype(bint full) const  # Get the resolved base type. Deserialization options: - if full=true...
        type_t get_decltype() const  # Get declared type (without resolving type references; they are retu...
        bint empty() const  # Was tinfo_t initialized with some type info or not?
        bint present() const  # Is the type really present? (not a reference to a missing type, for...
        int get_size(uint32 * p_effalign, int gts_code) const  # Get the type size in bytes.
        int get_unpadded_size() const  # Get the type size in bytes without the final padding, in bytes. For...
        uint32 get_alignment() const  # Get type alignment This function returns the effective type alignme...
        type_sign_t get_sign() const  # Get type sign
        bint is_signed() const  # Is this a signed type?
        bint is_unsigned() const  # Is this an unsigned type?
        uchar get_declalign() const  # Get declared alignment of the type
        bint is_typeref() const  # Is this type a type reference?.
        bint has_details() const  # Does this type refer to a nontrivial type?
        tinfo_code_t rename_type(const char * name, int ntf_flags)  # Rename a type
        tid_t get_tid() const  # Get the type tid Each type in the local type library has a so-calle...
        tid_t force_tid()  # Get the type tid. Create if it does not exist yet. If the type come...
        uint32 get_ordinal() const  # Get type ordinal (only if the type was created as a numbered type, ...
        uint32 get_final_ordinal() const  # Get final type ordinal (0 if none)
        til_t * get_til() const  # Get the type library for tinfo_t
        bint is_from_subtil() const  # Was the named type found in some base type library (not the top lev...
        bint is_forward_decl() const  # Is this a forward declaration?. Forward declarations are placeholde...
        type_t get_forward_type() const  # Get type of a forward declaration. For a forward declaration this f...
        bint is_forward_struct() const
        bint is_forward_union() const
        bint is_forward_enum() const
        bint is_typedef() const  # Is this a typedef?. This function will return true for a reference ...
        bint is_decl_const() const
        bint is_decl_volatile() const
        bint is_decl_void() const
        bint is_decl_partial() const
        bint is_decl_unknown() const
        bint is_decl_last() const
        bint is_decl_ptr() const
        bint is_decl_array() const
        bint is_decl_func() const
        bint is_decl_complex() const
        bint is_decl_typedef() const
        bint is_decl_sue() const
        bint is_decl_struct() const
        bint is_decl_union() const
        bint is_decl_udt() const
        bint is_decl_enum() const
        bint is_decl_bitfield() const
        bint is_decl_int128() const
        bint is_decl_int64() const
        bint is_decl_int32() const
        bint is_decl_int16() const
        bint is_decl_int() const
        bint is_decl_char() const
        bint is_decl_uint() const
        bint is_decl_uchar() const
        bint is_decl_uint16() const
        bint is_decl_uint32() const
        bint is_decl_uint64() const
        bint is_decl_uint128() const
        bint is_decl_ldouble() const
        bint is_decl_double() const
        bint is_decl_float() const
        bint is_decl_tbyte() const
        bint is_decl_floating() const
        bint is_decl_bool() const
        bint is_decl_paf() const
        bint is_well_defined() const
        bint is_const() const  # Probe the resolved type for various attributes:
        bint is_volatile() const
        bint is_void() const
        bint is_partial() const
        bint is_unknown() const
        bint is_ptr() const
        bint is_array() const
        bint is_func() const
        bint is_complex() const
        bint is_struct() const
        bint is_union() const
        bint is_udt() const
        bint is_enum() const
        bint is_sue() const
        bint is_bitfield() const
        bint is_int128() const
        bint is_int64() const
        bint is_int32() const
        bint is_int16() const
        bint is_int() const
        bint is_char() const
        bint is_uint() const
        bint is_uchar() const
        bint is_uint16() const
        bint is_uint32() const
        bint is_uint64() const
        bint is_uint128() const
        bint is_ldouble() const
        bint is_double() const
        bint is_float() const
        bint is_tbyte() const
        bint is_bool() const
        bint is_paf() const
        bint is_ptr_or_array() const
        bint is_integral() const
        bint is_ext_integral() const
        bint is_floating() const
        bint is_arithmetic() const
        bint is_ext_arithmetic() const
        bint is_scalar() const  # Does the type represent a single number?
        bint get_ptr_details(ptr_type_data_t * pi) const  # Get the pointer info.
        bint get_array_details(array_type_data_t * ai) const  # Get the array specific info
        bint get_enum_details(enum_type_data_t * ei) const  # Get the enum specific info
        bint get_bitfield_details(bitfield_type_data_t * bi) const  # Get the bitfield specific info
        bint get_udt_details(udt_type_data_t * udt, gtd_udt_t gtd) const  # Get the udt specific info
        bint get_func_details(func_type_data_t * fi, gtd_func_t gtd) const  # Get only the function specific info for this tinfo_t
        bint is_funcptr() const  # Is this pointer to a function?
        bint is_shifted_ptr() const  # Is a shifted pointer?
        bint is_varstruct() const  # Is a variable-size structure?
        bint is_varmember() const  # Can the type be of a variable struct member? This function checks f...
        int get_ptrarr_objsize() const  # ::BT_PTR & ::BT_ARRAY: get size of pointed object or array element....
        tinfo_t get_ptrarr_object() const  # ::BT_PTR & ::BT_ARRAY: get the pointed object or array element. If ...
        tinfo_t get_pointed_object() const  # ::BT_PTR: get type of pointed object. If the current type is not a ...
        bint is_pvoid() const  # Is "void *"?. This function does not check the pointer attributes a...
        bint is_punknown() const  # Is "_UNKNOWN *"?. This function does not check the pointer attribut...
        tinfo_t get_array_element() const  # ::BT_ARRAY: get type of array element. See also get_ptrarr_object()
        tinfo_t get_final_element() const  # repeat recursively: if an array, return the type of its element; el...
        int get_array_nelems() const  # ::BT_ARRAY: get number of elements (-1 means error)
        tinfo_t get_nth_arg(int n) const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get type of n-th arg (-1 means ret...
        tinfo_t get_rettype() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get the function's return type
        int get_nargs() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Calculate number of arguments (-1 ...
        bint is_user_cc() const
        bint is_vararg_cc() const
        bint is_purging_cc() const
        int calc_purged_bytes() const  # ::BT_FUNC: Calculate number of purged bytes
        bint is_high_func() const  # ::BT_FUNC: Is high level type?
        bint get_methods(udtmembervec_t * methods) const  # ::BT_COMPLEX: get a list of member functions declared in this udt.
        int find_udm(udm_t * udm, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find a udt member. - at the specified off...
        int find_udm(uint64 offset, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find an udt member at the specified offset
        int find_udm(const char * name, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find an udt member by name
        int get_udm(udm_t * out, const char * name) const  # Retrieve a structure/union member with the specified name
        int get_udm(udm_t * out, int index) const  # Retrieve a structure/union member with the specified index
        int get_udm_by_offset(udm_t * out, uint64 offset) const  # Retrieve a structure/union member with the specified offset
        int get_udt_nmembers() const  # Get number of udt members. -1-error
        bint is_empty_udt() const  # Is an empty struct/union? (has no fields)
        bint is_small_udt() const  # Is a small udt? (can fit a register or a pair of registers)
        uint32 get_udt_taudt_bits() const  # Get udt_type_data_t::taudt_bits
        bint is_unaligned_struct() const  # Is an unaligned struct
        bint is_msstruct() const  # Is gcc msstruct attribute applied
        bint is_cpp_struct() const  # Is a c++ object, not simple pod type
        bint is_vftable() const  # Is a vftable type?
        bint is_fixed_struct() const  # Is a structure with fixed offsets?
        bint is_tuple() const  # Is a tuple?
        bint is_one_fpval() const  # Floating value or an object consisting of one floating member entirely
        bint is_sse_type() const  # Is a SSE vector type?
        bint is_anonymous_udt() const  # Is an anonymous struct/union? We assume that types with names are a...
        bint has_vftable() const  # Has a vftable?
        bint has_union() const  # Has a member of type "union"?
        int get_enum_nmembers() const  # Get number of enum members.
        bint is_empty_enum() const  # Is an empty enum? (has no constants)
        type_t get_enum_base_type() const  # Get enum base type (convert enum to integer type) Returns ::BT_UNK ...
        bint is_bitmask_enum() const  # Is bitmask enum?
        int get_enum_radix() const  # Get enum constant radix
        tinfo_code_t get_enum_repr(value_repr_t * repr) const  # Set the representation of enum members.
        int get_enum_width() const  # Get enum width
        uint64 calc_enum_mask() const
        ssize_t get_edm(edm_t * out, const char * name) const  # Get enum member by its name
        tinfo_code_t get_edm(edm_t * edm, int idx) const  # Get enum member by its index
        ssize_t get_edm_by_value(edm_t * out, uint64 value, bmask64_t bmask, uchar serial) const  # Get enum member by its value
        tid_t get_edm_tid(int idx) const  # Get enum member TID
        tinfo_t get_onemember_type() const  # For objects consisting of one member entirely: return type of the m...
        tinfo_t get_innermost_udm(uint64 bitoffset, int * out_index, uint64 * out_bitoffset) const  # Get the innermost member at the given offset
        tinfo_t get_innermost_member_type(uint64 bitoffset, uint64 * out_bitoffset) const  # Get the innermost member type at the given offset
        uint32 calc_score() const  # Calculate the type score (the higher - the nicer is the type)
        const char * dstr() const  # Function to facilitate debugging
        bint set_attr(const type_attr_t & ta, bint may_overwrite)  # Set a type attribute. If necessary, a new typid will be created.
        void del_attrs()  # Del all type attributes. typerefs cannot be modified by this function.
        bint create_simple_type(type_t decl_type)
        bint create_ptr(const ptr_type_data_t & p, type_t decl_type)
        bint create_array(const array_type_data_t & p, type_t decl_type)
        bint create_bitfield(const bitfield_type_data_t & p, type_t decl_type)
        bint create_typedef(const typedef_type_data_t & p, type_t decl_type, bint try_ordinal)
        bint create_ptr(const tinfo_t & tif, uchar bps, type_t decl_type)  # @{
        bint create_array(const tinfo_t & tif, uint32 nelems, uint32 base, type_t decl_type)
        void create_typedef(const til_t * til, const char * name, type_t decl_type, bint try_ordinal)
        void create_typedef(const til_t * til, uint ord, type_t decl_type)
        bint create_bitfield(uchar nbytes, uchar width, bint is_unsigned, type_t decl_type)
        bint parse(const char * decl, til_t * til, int pt_flags)  # Convenience function to parse a string with a type declaration
        bint create_udt(bint is_union)  # Create an empty structure/union
        bint create_enum(bte_t bte)  # Create an empty enum
        bint create_udt(udt_type_data_t & p)  # These functions consume 'p' (make it empty) @{
        bint create_udt(udt_type_data_t & p, type_t decl_type)
        bint create_enum(enum_type_data_t & p, type_t decl_type)
        bint create_func(func_type_data_t & p, type_t decl_type)
        ssize_t get_udm_by_tid(udm_t * udm, tid_t tid)  # Retrive tinfo using type TID or struct/enum member MID
        ssize_t get_edm_by_tid(edm_t * edm, tid_t tid)
        bint get_type_by_tid(tid_t tid)
        ssize_t get_by_edm_name(const char * mname, const til_t * til)  # Retrieve enum tinfo using enum member name
        tinfo_code_t set_named_type(til_t * til, const char * name, int ntf_flags)  # Store the type info in the type library as a named or numbered type...
        tinfo_code_t set_symbol_type(til_t * til, const char * name, int ntf_flags)
        tinfo_code_t set_numbered_type(til_t * til, uint32 ord, int ntf_flags, const char * name)
        tinfo_code_t save_type(int ntf_flags)
        tinfo_code_t copy_type(til_t * til, const char * name, int ntf_flags)
        tinfo_code_t create_forward_decl(til_t * til, type_t decl_type, const char * name, int ntf_flags)  # Create a forward declaration. decl_type: ::BTF_STRUCT, ::BTF_UNION,...
        @staticmethod
        tinfo_t get_stock(stock_type_id_t id)  # Get stock type information. This function can be used to get tinfo_...
        bint convert_array_to_ptr()  # Convert an array into a pointer. type[] => type *
        bint remove_ptr_or_array()  # Replace the current type with the ptr obj or array element. This fu...
        uint64 read_bitfield_value(uint64 v, int bitoff) const  # Helper functions to store/extract bitfield values @{
        uint64 write_bitfield_value(uint64 dst, uint64 v, int bitoff) const
        type_t get_modifiers() const  # Work with type modifiers: const and volatile @{
        void set_modifiers(type_t mod)
        void set_const()
        void set_volatile()
        void clr_decl_const_volatile()  # remove modifiers for trivial types, without resolving the type
        bint clr_const()  # remove modifiers from non-trivial types. for example, if the type w...
        bint clr_volatile()
        bint clr_const_volatile()
        tinfo_code_t set_type_alignment(uchar declalign, uint etf_flags)  # Set type alignment
        bint set_declalign(uchar declalign)
        bint change_sign(type_sign_t sign)  # Change the type sign. Works only for the types that may have sign
        bint calc_udt_aligns(int sudt_flags)  # Calculate the udt alignments using the field offsets/sizes and the ...
        bint set_methods(udtmembervec_t & methods)  # ::BT_COMPLEX: set the list of member functions. This function consu...
        tinfo_code_t set_type_cmt(const char * cmt, bint is_regcmt, uint etf_flags)  # Set type comment This function works only for non-trivial types
        uint32 get_alias_target() const  # Get type alias If the type has no alias, return 0.
        bint is_aliased() const
        bint set_type_alias(uint32 dest_ord)  # Set type alias Redirects all references to source type to the desti...
        tinfo_code_t set_udt_alignment(int sda, uint etf_flags)  # Set declared structure alignment (sda) This alignment supersedes th...
        tinfo_code_t set_udt_pack(int pack, uint etf_flags)  # Set structure packing. The value controls how little a structure me...
        tid_t get_udm_tid(int idx) const  # Get udt member TID
        tinfo_code_t add_udm(const udm_t & udm, uint etf_flags, int times, ssize_t idx)  # Add a structure/union member.
        tinfo_code_t add_udm(const char * name, const tinfo_t & type, uint64 offset, uint etf_flags, int times, ssize_t idx)  # Add a structure/union member.
        tinfo_code_t add_udm(const char * name, type_t type, uint64 offset, uint etf_flags, int times, ssize_t idx)  # Add a structure/union member.
        tinfo_code_t add_udm(const char * name, const char * type, uint64 offset, uint etf_flags, int times, ssize_t idx)  # Add a structure/union member.
        tinfo_code_t del_udm(int index, uint etf_flags)  # Delete a structure/union member.
        tinfo_code_t del_udms(int idx1, int idx2, uint etf_flags)  # Delete structure/union members in the range [idx1, idx2)
        tinfo_code_t rename_udm(int index, const char * name, uint etf_flags)  # Rename a structure/union member. The new name must be unique.
        tinfo_code_t set_udm_type(int index, const tinfo_t & tif, uint etf_flags, const value_repr_t * repr)  # Set type of a structure/union member.
        tinfo_code_t set_udm_cmt(int index, const char * cmt, bint is_regcmt, uint etf_flags)  # Set a comment for a structure/union member. A member may have just ...
        tinfo_code_t set_udm_repr(int index, const value_repr_t & repr, uint etf_flags)  # Set the representation of a structure/union member.
        bint is_udm_by_til(int idx) const  # Was the member created due to the type system
        tinfo_code_t set_udm_by_til(int idx, bint on, uint etf_flags)  # The member is created due to the type system
        tinfo_code_t set_fixed_struct(bint on)  # Declare struct member offsets as fixed. For such structures, IDA wi...
        tinfo_code_t set_struct_size(int new_size)  # Explicitly specify the struct size. This function works only with f...
        tinfo_code_t expand_udt(int idx, adiff_t delta, uint etf_flags)  # Expand/shrink a structure by adding/removing a gap before the speci...
        tinfo_code_t set_tuple(bint on)  # Declare struct as a tuple. Currently, tuples in IDA behave the same...
        bint get_func_frame(const func_t * pfn)  # Create a tinfo_t object for the function frame
        bint is_frame() const  # Is a function frame?
        ea_t get_frame_func() const  # Get function address for the frame
        tinfo_code_t set_enum_width(int nbytes, uint etf_flags)  # Set the width of enum base type
        tinfo_code_t set_enum_sign(type_sign_t sign, uint etf_flags)  # Set enum sign
        tinfo_code_t set_enum_repr(const value_repr_t & repr, uint etf_flags)  # Set the representation of enum members.
        tinfo_code_t set_enum_radix(int radix, bint sign, uint etf_flags)  # Set enum radix to display constants
        tinfo_code_t add_edm(const edm_t & edm, bmask64_t bmask, uint etf_flags, ssize_t idx)  # Add a new enum member (a new symbolic constant)
        tinfo_code_t add_edm(const char * name, uint64 value, bmask64_t bmask, uint etf_flags, ssize_t idx)  # Add a new enum member (a new symbolic constant)
        tinfo_code_t del_edms(int idx1, int idx2, uint etf_flags)  # Delete enum members
        tinfo_code_t del_edm(int idx, uint etf_flags)
        tinfo_code_t del_edm(const char * name, uint etf_flags)  # Delete enum member by its name
        tinfo_code_t del_edm_by_value(uint64 value, uint etf_flags, bmask64_t bmask, uchar serial)  # Delete enum member by its value
        tinfo_code_t rename_edm(int idx, const char * name, uint etf_flags)  # Rename a enum member
        tinfo_code_t set_edm_cmt(int idx, const char * cmt, uint etf_flags)  # Set a comment for an enum member. Such comments are always consider...
        tinfo_code_t edit_edm(int idx, uint64 value, bmask64_t bmask, uint etf_flags)  # Change constant value and/or bitmask
        tinfo_code_t rename_funcarg(int index, const char * name, uint etf_flags)  # Rename a function argument. The new name must be unique.
        tinfo_code_t set_funcarg_type(int index, const tinfo_t & tif, uint etf_flags)  # Set type of a function argument.
        tinfo_code_t set_func_rettype(const tinfo_t & tif, uint etf_flags)  # Set function return type .
        tinfo_code_t del_funcargs(int idx1, int idx2, uint etf_flags)  # Delete function arguments
        tinfo_code_t del_funcarg(int idx, uint etf_flags)
        tinfo_code_t add_funcarg(const funcarg_t & farg, uint etf_flags, ssize_t idx)  # Add a function argument.
        tinfo_code_t set_funcarg_loc(int index, const argloc_t & argloc, uint etf_flags)  # Set location of a function argument.
        tinfo_code_t set_func_retloc(const argloc_t & argloc, uint etf_flags)  # Set location of function return value.
        bint operator==(const tinfo_t & r) const
        bint operator!=(const tinfo_t & r) const
        bint operator<(const tinfo_t & r) const
        bint operator>(const tinfo_t & r) const
        bint operator<=(const tinfo_t & r) const
        bint operator>=(const tinfo_t & r) const
        int compare(const tinfo_t & r) const
        bint compare_with(const tinfo_t & r, int tcflags) const  # @} Compare two types, based on given flags (see TCMP_)
        bint equals_to(const tinfo_t & r) const
        bint is_castable_to(const tinfo_t & target) const
        bint is_manually_castable_to(const tinfo_t & target) const
    cdef cppclass simd_info_t:  # -------------------------------------------------------------------...
        const char * name  # name of SIMD type (nullptr-undefined)
        tinfo_t tif  # SIMD type (empty-undefined)
        uint16 size  # SIMD type size in bytes (0-undefined)
        type_t memtype  # member type BTF_INT8/16/32/64/128, BTF_UINT8/16/32/64/128 BTF_INT -...
        simd_info_t(const char * nm, uint16 sz, type_t memt)
        bint match_pattern(const simd_info_t * pattern)
    cdef cppclass ptr_type_data_t:  # -------------------------------------------------------------------...
        tinfo_t obj_type  # pointed object type
        tinfo_t closure  # cannot have both closure and based_ptr_size
        tinfo_t parent  # Parent struct
        int32 delta  # Offset from the beginning of the parent struct
        uchar based_ptr_size
        uchar taptr_bits  # TAH bits
        ptr_type_data_t(tinfo_t c, uchar bps, tinfo_t p, int32 d)
        void swap(ptr_type_data_t & r)
        bint operator==(const ptr_type_data_t & r) const
        bint operator!=(const ptr_type_data_t & r) const
        bint is_code_ptr() const
        bint is_shifted() const
    cdef cppclass array_type_data_t:  # -------------------------------------------------------------------...
        tinfo_t elem_type  # element type
        uint32 base  # array base
        uint32 nelems  # number of elements
        array_type_data_t(int b, int n)
        void swap(array_type_data_t & r)
    cdef cppclass funcarg_t:  # -------------------------------------------------------------------...
        argloc_t argloc  # argument location
        tinfo_t type  # argument type
        uint32 flags  # FAI_
        funcarg_t()  # @}
        funcarg_t(const char * _name, const tinfo_t & _type, const argloc_t & _argloc)  # Create a function argument, with the specified name and arbitrary t...
        funcarg_t(const char * _name, const type_t _type, const argloc_t & _argloc)  # Create a function argument, with the specified name and simple type.
        funcarg_t(const char * _name, const char * _type, const argloc_t & _argloc)  # Create a function argument, with the specified name and type.
        bint operator==(const funcarg_t & r) const
        bint operator!=(const funcarg_t & r) const
    cdef cppclass func_type_data_t:  # Function type information (see tinfo_t::get_func_details())
        int flags  # FTI_
        tinfo_t rettype  # return type
        argloc_t retloc  # return location
        uval_t stkargs  # size of stack arguments (not used in build_func_type)
        cm_t _old_cc  # calling convention, legacy codes. do not access
        void swap(func_type_data_t & r)
        bint is_high() const
        bint is_noret() const
        bint is_pure() const
        bint is_static() const
        bint is_virtual() const
        bint is_const() const
        bint is_ctor() const
        bint is_dtor() const
        int get_call_method() const
        bint is_vararg_cc() const
        bint is_golang_cc() const
        bint is_swift_cc() const
        bint is_user_cc() const
        ssize_t find_argument(const char * name, int from_, int to) const  # find argument by name
    cdef cppclass edm_t:  # -------------------------------------------------------------------...
        uint64 value
        edm_t()
        edm_t(const char * _name, uint64 _value, const char * _cmt)  # Create an enumeration value with the specified name and value
        bint empty() const  # a enum constant must at least have a name
        bint operator==(const edm_t & r) const
        bint operator!=(const edm_t & r) const
        void swap(edm_t & r)
        tid_t get_tid() const
    cdef cppclass enum_type_data_t:  # Enum type information (see tinfo_t::get_enum_details())
        uint32 taenum_bits  # tattr_enum
        bte_t bte  # enum member sizes (shift amount) and style. do not manually set BTE...
        enum_type_data_t(bte_t _bte)
        int get_enum_radix() const  # How the enum members should be printed in the enum definition Get e...
        bint is_number_signed() const
        void set_enum_radix(int radix, bint sign)  # Set radix to display constants
        bint is_char() const
        bint is_dec() const
        bint is_hex() const
        bint is_oct() const
        bint is_bin() const
        bint is_udec() const
        bint is_shex() const
        bint is_soct() const
        bint is_sbin() const
        bint has_lzero() const
        void set_lzero(bint on)
        uint64 calc_mask() const
        bint store_64bit_values() const
        bint is_bf() const  # is bitmask or ordinary enum?
        int calc_nbytes() const  # get the width of enum in bytes
        bint set_nbytes(int nbytes)  # set enum width (nbytes)
        bint get_constant_group(int * group_start_index, int * group_size, int idx) const  # get group parameters for the constant, valid for bitmask enum
        bint is_group_mask_at(int idx) const  # is the enum member at IDX a non-trivial group mask? a trivial group...
        bint is_valid_group_sizes() const  # is valid group sizes
        ssize_t find_member(const char * name, int from_, int to) const  # find member (constant or bmask) by name
        ssize_t find_member(uint64 value, uchar serial, int from_, int to, uint64 vmask) const  # find member (constant or bmask) by value
        void swap(enum_type_data_t & r)  # swap two instances
        void add_constant(const char * name, uint64 value, const char * cmt)  # add constant for regular enum
        tinfo_code_t get_value_repr(value_repr_t * repr) const  # get enum radix and other representation info
        tinfo_code_t set_value_repr(const value_repr_t & repr)  # set enum radix and other representation info
        uchar get_serial(int index) const  # returns serial for the constant
        uchar get_max_serial(uint64 value) const  # return the maximum serial for the value
    cdef cppclass typedef_type_data_t:  # -------------------------------------------------------------------...
        const til_t * til  # type library to use when resolving
        const char * name  # is_ordref=false: target type name. we do not own this pointer!
        uint32 ordinal  # is_ordref=true: type ordinal number
        bint is_ordref  # is reference by ordinal?
        bint resolve  # should resolve immediately?
        typedef_type_data_t(const til_t * _til, const char * _name, bint _resolve)
        typedef_type_data_t(const til_t * _til, uint32 ord, bint _resolve)
        void swap(typedef_type_data_t & r)
    cdef cppclass custom_data_type_info_t:  # -------------------------------------------------------------------...
        int16 dtid  # data type id
        int16 fid  # data format ids
    cdef cppclass value_repr_t:  # Visual representation of a member of a complex type (struct/union/e...
        uint64 bits
        int32 strtype  # FRB_STRLIT
        custom_data_type_info_t cd  # FRB_CUSTOM
        void swap(value_repr_t & r)
        void clear()
        bint empty() const
        bint is_enum() const
        bint is_offset() const
        bint is_strlit() const
        bint is_custom() const
        bint is_stroff() const
        bint is_typref() const
        bint is_signed() const
        bint has_tabform() const
        bint has_lzeroes() const
        uint64 get_vtype() const
        void set_vtype(uint64 vt)
        void set_signed(bint on)
        void set_tabform(bint on)
        void set_lzeroes(bint on)
    cdef cppclass udm_t:  # -------------------------------------------------------------------...
        uint64 offset  # member offset in bits
        uint64 size  # size in bits
        tinfo_t type  # member type
        value_repr_t repr  # radix, refinfo, strpath, custom_id, strtype
        int effalign  # effective field alignment (in bytes)
        uint32 tafld_bits  # TAH bits
        uchar fda  # field alignment (shift amount)
        udm_t()
        udm_t(const char * _name, const tinfo_t & _type, uint64 _offset)  # Create a structure/union member, with the specified name and arbitr...
        udm_t(const char * _name, const type_t _type, uint64 _offset)  # Create a structure/union member, with the specified name and simple...
        udm_t(const char * _name, const char * _type, uint64 _offset)  # Create a structure/union member, with the specified name and type.
        bint empty() const  # a udt member must at least have a type
        bint is_bitfield() const
        bint is_zero_bitfield() const
        bint is_unaligned() const
        bint is_baseclass() const
        bint is_virtbase() const
        bint is_vftable() const
        bint is_method() const
        bint is_gap() const
        bint is_regcmt() const
        bint is_retaddr() const
        bint is_savregs() const
        bint is_special_member() const
        bint is_by_til() const
        void set_unaligned(bint on)
        void set_baseclass(bint on)
        void set_virtbase(bint on)
        void set_vftable(bint on)
        void set_method(bint on)
        void set_regcmt(bint on)
        void set_retaddr(bint on)
        void set_savregs(bint on)
        void set_by_til(bint on)
        void clr_unaligned()
        void clr_baseclass()
        void clr_virtbase()
        void clr_vftable()
        void clr_method()
        uint64 begin() const
        uint64 end() const
        bint operator<(const udm_t & r) const
        bint operator==(const udm_t & r) const
        bint compare_with(const udm_t & r, int tcflags) const
        bint operator!=(const udm_t & r) const
        void swap(udm_t & r)
        bint is_anonymous_udm() const  # the user cannot enter anonymous fields in ida (they can come only f...
        void set_value_repr(const value_repr_t & r)
        bint can_be_dtor() const
        bint can_rename() const
    cdef cppclass udtmembervec_t:
        pass
    cdef cppclass udt_type_data_t(udtmembervec_t):
        int total_size  # total structure size in bytes
        int unpadded_size  # unpadded structure size in bytes
        uint32 effalign  # effective structure alignment (in bytes)
        uint32 taudt_bits  # TA... and TAUDT... bits
        uchar version  # version of udt_type_data_t
        uchar sda  # declared structure alignment (shift amount+1). 0 - unspecified
        uchar pack  # #pragma pack() alignment (shift amount)
        bint is_union  # is union or struct?
        void swap(udt_type_data_t & r)
        bint is_unaligned() const
        bint is_msstruct() const
        bint is_cppobj() const
        bint is_vftable() const
        bint is_fixed() const
        bint is_tuple() const
        void set_vftable(bint on)
        void set_fixed(bint on)
        void set_tuple(bint on)
        bint is_last_baseclass(int idx)
        udm_t & add_member(const char * _name, const tinfo_t & _type, uint64 _offset)  # Add a new member to a structure or union. This function just pushes...
        ssize_t find_member(udm_t * pattern_udm, int strmem_flags) const  # tinfo_t::find_udm
        ssize_t find_member(const char * name) const
        ssize_t find_member(uint64 bit_offset) const
        ssize_t get_best_fit_member(asize_t disp) const  # Get the member that is most likely referenced by the specified offs...
        ssize_t get_best_fit_member(udm_t * out, asize_t disp) const  # Get the member that is most likely referenced by the specified offs...
    cdef cppclass udm_visitor_t:  # -------------------------------------------------------------------...
        int visit_udm(tid_t tid, const tinfo_t * tif, const udt_type_data_t * udt, ssize_t idx)
    cdef cppclass bitfield_type_data_t:  # -------------------------------------------------------------------...
        uchar nbytes  # enclosing type size (1,2,4,8 bytes)
        uchar width  # number of bits
        bint is_unsigned  # is bitfield unsigned?
        bitfield_type_data_t(uchar _nbytes, uchar _width, bint _is_unsigned)
        bint operator==(const bitfield_type_data_t & r) const
        bint operator!=(const bitfield_type_data_t & r) const
        bint operator<(const bitfield_type_data_t & r) const
        bint operator>(const bitfield_type_data_t & r) const
        bint operator<=(const bitfield_type_data_t & r) const
        bint operator>=(const bitfield_type_data_t & r) const
        int compare(const bitfield_type_data_t & r) const
        void swap(bitfield_type_data_t & r)
        bint is_valid_bitfield() const
    cdef cppclass type_mods_t:  # Information about how to modify the current type, used by ::tinfo_v...
        tinfo_t type  # current type
        int flags  # TVIS_
        void clear()  # @}
        void set_new_type(const tinfo_t & t)  # The visit_type() function may optionally save the modified type inf...
        bint has_type() const
        bint has_name() const
        bint has_cmt() const
        bint is_rptcmt() const
        bint has_info() const
    cdef cppclass tinfo_visitor_t:  # Visit all subtypes of a type. Derive your visitor from this class a...
        int state  # TVST_
        int level  # recursion level (internal use)
        tinfo_visitor_t(int s)
        int visit_type(type_mods_t * out, const tinfo_t & tif, const char * name, const char * cmt)  # Visit a subtype. this function must be implemented in the derived c...
        void prune_now()  # To refuse to visit children of the current type, use this:
        int apply_to(const tinfo_t & tif, type_mods_t * out, const char * name, const char * cmt)  # Call this function to initiate the traversal
    cdef cppclass regobj_t:  # Object that represents a register
        int regidx  # index into dbg->registers
        int relocate  # 0-plain num, 1-must relocate
        int size() const
    cdef cppclass regobjs_t:
        pass
    cdef cppclass argtinfo_helper_t:  # -------------------------------------------------------------------...
        int reserved
        bint has_delay_slot(ea_t arg38)  # The call instruction with a delay slot?.
    cdef cppclass lowertype_helper_t:  # -------------------------------------------------------------------...
        bint func_has_stkframe_hole(const tinfo_t & candidate, const func_type_data_t & candidate_data)
        int get_func_purged_bytes(const tinfo_t & candidate, const func_type_data_t & candidate_data)
    cdef cppclass ida_lowertype_helper_t(lowertype_helper_t):  # -------------------------------------------------------------------...
        ida_lowertype_helper_t(const tinfo_t & _tif, ea_t _ea, int _pb)
        bint func_has_stkframe_hole(const tinfo_t & candidate, const func_type_data_t & candidate_data)
        int get_func_purged_bytes(const tinfo_t & candidate, const func_type_data_t & arg9)
    cdef cppclass format_data_info_t:  # -------------------------------------------------------------------...
        int ptvf
        int radix  # number representation (8,10,16)
        int max_length  # max length of the formatted text (0 means no limit) should be used ...
        int arrbase  # for arrays: the first element of array to print
        int arrnelems  # for arrays: number of elements to print
        int margin  # length of one line (0 means to print everything on one line) if an ...
        int indent  # how many spaces to use to indent nested structures/arrays
        format_data_info_t()
    cdef cppclass valinfo_t:  # Additional information about the output lines
        argloc_t loc
        tinfo_t type
        valinfo_t(argloc_t l, const char * name, const tinfo_t & tif)
        void swap(valinfo_t & r)
    cdef cppclass valstr_t:  # Text representation of a data value (value string). This structure ...
        int length  # length if printed on one line
        valstrs_t * members  # strings for members, each member separately
        valinfo_t * info  # additional info
        int props  # temporary properties, used internally
        valstr_t()
    cdef cppclass valstrs_t:
        pass
    cdef cppclass text_sink_t:  # Flush formatted text
        int print(const char * str)  # Returns 0-ok, otherwise print_cdata will stop
    cdef cppclass til_symbol_t:  # A symbol in a type library
        const char * name  # symbol name
        const til_t * til  # pointer to til
        til_symbol_t(const char * n, const til_t * t)
    cdef cppclass predicate_t:  # Helper class for choose_named_type(). Controls which types are disp...
        bint should_display(const til_t * til, const char * name, const type_t * type, const p_list * fields)
    cdef cppclass til_type_ref_t:  # -------------------------------------------------------------------...
        int cb
        tinfo_t tif  # type info, !empty() during runtime
        uint32 ordinal  # cached value of tif.get_ordinal()
        bint is_writable  # can we modify the type? (either in a RW til, or writable backend)
        bint is_detached  # type is not backed by a backend that will cause views to be updated...
        bint is_forward  # is the type a forward declaration?
        type_t kind  # one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENUM, BT_FUNC
        ssize_t memidx  # index of the current BTF_STRUCT, BTF_UNION, BTF_ENUM member or BT_F...
        int nmembers  # number of members in the BTF_STRUCT, BTF_UNION, BTF_ENUM or number ...
        udm_t udm  # BTF_STRUCT or BTF_UNION: the current member
        int total_size
        int unpadded_size
        uint64 last_udm_offset
        uint64 bucket_start  # bucket offset (equal to 'offset' except for bitfields)
        int bf_bitoff  # for bitfields, bit offset from bucket_start
        uint64 offset  # the current offset (regardless if we have a defined member at the c...
        edm_t edm  # BTF_ENUM: the current enum member
        const funcarg_t * fa  # BT_FUNC: the current argument, nullptr - ellipsis
        void clear()
        bint on_member() const
        bint is_typedef() const
        bint is_struct() const
        bint is_union() const
        bint is_enum() const
        bint is_func() const
        bint is_udt() const
    bint is_type_const(type_t t)  # -------------------------------------------------------------------...
    bint is_type_volatile(type_t t)
    type_t get_base_type(type_t t)
    type_t get_type_flags(type_t t)
    type_t get_full_type(type_t t)
    bint is_typeid_last(type_t t)  # Is the type_t the last byte of type declaration? (there are no addi...
    bint is_type_partial(type_t t)  # Identifies an unknown or void type with a known size (see tf_unk)
    bint is_type_void(type_t t)
    bint is_type_unknown(type_t t)
    bint is_type_ptr(type_t t)
    bint is_type_complex(type_t t)
    bint is_type_func(type_t t)
    bint is_type_array(type_t t)
    bint is_type_typedef(type_t t)
    bint is_type_sue(type_t t)
    bint is_type_struct(type_t t)
    bint is_type_union(type_t t)
    bint is_type_struni(type_t t)
    bint is_type_enum(type_t t)
    bint is_type_bitfld(type_t t)
    bint is_type_int(type_t bt)  # Does the type_t specify one of the basic types in tf_int?
    bint is_type_int128(type_t t)  # Does the type specify a 128-bit value? (signed or unsigned, see tf_...
    bint is_type_int64(type_t t)  # Does the type specify a 64-bit value? (signed or unsigned, see tf_int)
    bint is_type_int32(type_t t)  # Does the type specify a 32-bit value? (signed or unsigned, see tf_int)
    bint is_type_int16(type_t t)  # Does the type specify a 16-bit value? (signed or unsigned, see tf_int)
    bint is_type_char(type_t t)  # Does the type specify a char value? (signed or unsigned, see tf_int)
    bint is_type_paf(type_t t)  # Is the type a pointer, array, or function type?
    bint is_type_ptr_or_array(type_t t)  # Is the type a pointer or array type?
    bint is_type_floating(type_t t)  # Is the type a floating point type?
    bint is_type_integral(type_t t)  # Is the type an integral type (char/short/int/long/bool)?
    bint is_type_ext_integral(type_t t)  # Is the type an extended integral type? (integral or enum)
    bint is_type_arithmetic(type_t t)  # Is the type an arithmetic type? (floating or integral)
    bint is_type_ext_arithmetic(type_t t)  # Is the type an extended arithmetic type? (arithmetic or enum)
    bint is_type_uint(type_t t)
    bint is_type_uchar(type_t t)
    bint is_type_uint16(type_t t)
    bint is_type_uint32(type_t t)
    bint is_type_uint64(type_t t)
    bint is_type_uint128(type_t t)
    bint is_type_ldouble(type_t t)
    bint is_type_double(type_t t)
    bint is_type_float(type_t t)
    bint is_type_tbyte(type_t t)
    bint is_type_bool(type_t t)
    bint is_tah_byte(type_t t)  # The TAH byte (type attribute header byte) denotes the start of type...
    bint is_sdacl_byte(type_t t)  # Identify an sdacl byte. The first sdacl byte has the following form...
    bint extract_argloc(argloc_t * vloc, const type_t ** ptype, bint forbid_stkoff)  # Deserialize an argument location. Argument FORBID_STKOFF checks loc...
    const type_t * resolve_typedef(const til_t * til, const type_t * type)
    bint is_restype_void(const til_t * til, const type_t * type)  # low level functions to be used in predicate_t::should_display() in ...
    bint is_restype_enum(const til_t * til, const type_t * type)
    bint is_restype_struni(const til_t * til, const type_t * type)
    bint is_restype_struct(const til_t * til, const type_t * type)
    type_t get_scalar_bt(int size)  # Get a base type for the specified size. This function prefers to re...
    til_t * new_til(const char * name, const char * desc)  # Initialize a til
    bint sort_til(til_t * ti)  # Sort til (use after modifying it).
    bint compact_til(til_t * ti)  # Collect garbage in til. Must be called before storing the til.
    bint store_til(til_t * ti, const char * tildir, const char * name)  # Store til to a file. If the til contains garbage, it will be collec...
    void free_til(til_t * ti)  # Free memory allocated by til
    bint is_code_far(cm_t cm)  # Does the given model specify far code?.
    bint is_data_far(cm_t cm)  # Does the given model specify far data?.
    int install_custom_argloc(const custloc_desc_t * custloc)  # Save a custom argloc
    bint remove_custom_argloc(int idx)  # Delete the custom argloc at the given index
    const custloc_desc_t * retrieve_custom_argloc(int idx)  # Retrieve the custom argloc at the given index
    int print_argloc(char * buf, int bufsize, const argloc_t & vloc, int size, int vflags)  # Convert an argloc to human readable form
    int for_all_arglocs(aloc_visitor_t & vv, argloc_t & vloc, int size, int off)  # Compress larger argloc types and initiate the aloc visitor
    int for_all_const_arglocs(const_aloc_visitor_t & vv, const argloc_t & vloc, int size, int off)  # See for_all_arglocs()
    comp_t get_comp(comp_t comp)  # Get compiler bits
    const char * get_compiler_name(comp_t id)  # Get full compiler name
    const char * get_compiler_abbr(comp_t id)  # Get abbreviated compiler name
    comp_t is_comp_unsure(comp_t comp)  # See ::COMP_UNSURE
    comp_t default_compiler()  # Get compiler specified by {inf,idainfo,cc}
    bint is_gcc()  # Is the target compiler ::COMP_GNU?
    bint is_gcc32()  # Is the target compiler 32 bit gcc?
    bint is_gcc64()  # Is the target compiler 64 bit gcc?
    bint gcc_layout()  # Should use the struct/union layout as done by gcc?
    bint set_compiler_id(comp_t id, const char * abiname)  # Set the compiler id (see COMP_)
    bint set_abi_name(const char * abiname, bint user_level)  # Set abi name (see COMP_)
    bint append_abi_opts(const char * abi_opts, bint user_level)  # Add/remove/check ABI option General form of full abi name: abiname-...
    bint remove_abi_opts(const char * abi_opts, bint user_level)
    bint set_compiler_string(const char * compstr, bint user_level)  # Returns success
    bint use_golang_cc()  # is GOLANG calling convention used by default?
    void switch_to_golang()  # switch to GOLANG calling convention (to be used as default CC)
    int convert_pt_flags_to_hti(int pt_flags)  # Convert PT_ to HTI_. Type parsing flags lesser than 0x10 don't have...
    int get_named_type(const til_t * ti, const char * name, int ntf_flags, const type_t ** type, const p_list ** fields, const char ** cmt, const p_list ** fieldcmts, sclass_t * sclass, uint32 * value)  # Get named typeinfo. The returned pointers are pointers to static st...
    int get_named_type64(const til_t * ti, const char * name, int ntf_flags, const type_t ** type, const p_list ** fields, const char ** cmt, const p_list ** fieldcmts, sclass_t * sclass, uint64 * value)  # See get_named_type() above.
    const char * tinfo_errstr(tinfo_code_t code)  # Helper function to convert an error code into a printable string. A...
    bint del_named_type(til_t * ti, const char * name, int ntf_flags)  # Delete information about a symbol.
    const char * first_named_type(const til_t * ti, int ntf_flags)  # Enumerate types.
    const char * next_named_type(const til_t * ti, const char * name, int ntf_flags)  # first_named_type()
    uint32 copy_named_type(til_t * dsttil, const til_t * srctil, const char * name)  # Copy a named type from one til to another. This function will copy ...
    bint enable_numbered_types(til_t * ti, bint enable)  # Enable the use of numbered types in til. Currently it is impossible...
    bint get_numbered_type(const til_t * ti, uint32 ordinal, const type_t ** type, const p_list ** fields, const char ** cmt, const p_list ** fieldcmts, sclass_t * sclass)  # Retrieve a type by its ordinal number
    uint32 alloc_type_ordinals(til_t * ti, int qty)  # Allocate a range of ordinal numbers for new types.
    uint32 alloc_type_ordinal(til_t * ti)  # {alloc_type_ordinals,ti,1}
    uint32 get_ordinal_limit(const til_t * ti)  # Get number of allocated ordinals + 1. If there are no allocated ord...
    uint32 get_ordinal_count(const til_t * ti)  # Get number of allocated ordinals.
    bint del_numbered_type(til_t * ti, uint32 ordinal)  # Delete a numbered type
    bint set_type_alias(til_t * ti, uint32 src_ordinal, uint32 dst_ordinal)  # Create a type alias. Redirects all references to source type to the...
    uint32 get_alias_target(const til_t * ti, uint32 ordinal)  # Find the final alias destination. If the ordinal has not been alias...
    int32 get_type_ordinal(const til_t * ti, const char * name)  # Get type ordinal by its name
    const char * get_numbered_type_name(const til_t * ti, uint32 ordinal)  # Get type name (if exists) by its ordinal. If the type is anonymous,...
    bint is_ordinal_name(const char * name, uint32 * ord)  # Check if the name is an ordinal name. Ordinal names have the follow...
    bint is_type_choosable(const til_t * ti, uint32 ordinal)  # Check if a struct/union type is choosable
    void set_type_choosable(til_t * ti, uint32 ordinal, bint value)  # Enable/disable 'choosability' flag for a struct/union type
    ea_t get_vftable_ea(uint32 ordinal)  # Get address of a virtual function table.
    uint32 get_vftable_ordinal(ea_t vftable_ea)  # Get ordinal number of the virtual function table.
    bint set_vftable_ea(uint32 ordinal, ea_t vftable_ea)  # Set the address of a vftable instance for a vftable type.
    bint del_vftable_ea(uint32 ordinal)  # Delete the address of a vftable instance for a vftable type.
    int get_default_align()  # Get default alignment for structure fields.
    void align_size(int & cur_tot_size, int elem_size, int algn)  # Get alignment delta for the a structure field.
    bint deref_ptr(ea_t * ptr_ea, const tinfo_t & tif, ea_t * closure_obj)  # Dereference a pointer.
    bint remove_tinfo_pointer(tinfo_t * tif, const char ** pname, const til_t * til)  # Remove pointer of a type. (i.e. convert "char *" into "char"). Opti...
    int add_til(const char * name, int flags)  # Load a til file and add it the database type libraries list. IDA wi...
    bint del_til(const char * name)  # Unload a til file
    bint apply_named_type(ea_t ea, const char * name)  # Apply the specified named type to the address.
    bint apply_tinfo(ea_t ea, const tinfo_t & tif, uint32 flags)  # Apply the specified type to the specified address. This function se...
    bint apply_cdecl(til_t * til, ea_t ea, const char * decl, int flags)  # Apply the specified type to the address. This function parses the d...
    bint apply_callee_tinfo(ea_t caller, const tinfo_t & tif)  # Apply the type of the called function to the calling instruction. T...
    bint apply_once_tinfo_and_name(ea_t dea, const tinfo_t & tif, const char * name)  # Apply the specified type and name to the address. This function che...
    int guess_tinfo(tinfo_t * out, tid_t id)  # Generate a type information about the id from the disassembly. id c...
    void set_c_header_path(const char * incdir)  # Set include directory path the target compiler
    void set_c_macros(const char * macros)  # Set predefined macros for the target compiler
    til_t * get_idati()  # Pointer to the local type library - this til is private for each ID...
    bint get_tinfo_by_flags(tinfo_t * out, flags64_t flags)  # Get tinfo object that corresponds to data flags
    void copy_tinfo_t(tinfo_t * _this, const tinfo_t & r)
    bint detach_tinfo_t(tinfo_t * _this)
    void clear_tinfo_t(tinfo_t * _this)
    bint create_tinfo(tinfo_t * _this, type_t bt, type_t bt2, void * ptr)
    int verify_tinfo(typid_t typid)
    bint get_tinfo_details(typid_t typid, type_t bt2, void * buf)
    int get_tinfo_size(uint32 * p_effalign, typid_t typid, int gts_code)
    int get_tinfo_pdata(void * outptr, typid_t typid, int what)
    int get_tinfo_property(typid_t typid, int gta_prop)
    int get_tinfo_property4(typid_t typid, int gta_prop, int p1, int p2, int p3, int p4)
    int set_tinfo_property(tinfo_t * tif, int sta_prop, int x)
    int set_tinfo_property4(tinfo_t * tif, int sta_prop, int p1, int p2, int p3, int p4)
    bint deserialize_tinfo(tinfo_t * tif, const til_t * til, const type_t ** ptype, const p_list ** pfields, const p_list ** pfldcmts, const char * cmt)
    int find_tinfo_udt_member(udm_t * udm, typid_t typid, int strmem_flags)
    const char * dstr_tinfo(const tinfo_t * tif)
    int visit_subtypes(tinfo_visitor_t * visitor, type_mods_t * out, const tinfo_t & tif, const char * name, const char * cmt)
    bint compare_tinfo(typid_t t1, typid_t t2, int tcflags)
    int lexcompare_tinfo(typid_t t1, typid_t t2, int arg1)
    bint get_stock_tinfo(tinfo_t * tif, stock_type_id_t id)
    uint64 read_tinfo_bitfield_value(typid_t typid, uint64 v, int bitoff)
    uint64 write_tinfo_bitfield_value(typid_t typid, uint64 dst, uint64 v, int bitoff)
    bint set_tinfo_attr(tinfo_t * tif, const type_attr_t & ta, bint may_overwrite)
    uint32 score_tinfo(const tinfo_t * tif)
    tinfo_code_t save_tinfo(tinfo_t * tif, til_t * til, int ord, const char * name, int ntf_flags)
    ssize_t udt_type_data_t__find_member(const udt_type_data_t * _this, udm_t * udm, int strmem_flags)
    ssize_t udt_type_data_t__get_best_fit_member(const udt_type_data_t * _this, asize_t disp)
    uchar enum_type_data_t__get_max_serial(const enum_type_data_t * ei, uint64 value)
    tinfo_code_t enum_type_data_t__set_value_repr(enum_type_data_t * ei, const value_repr_t & repr)
    tinfo_code_t enum_type_data_t__get_value_repr(const enum_type_data_t * ei, value_repr_t * repr)
    void tinfo_get_innermost_udm(tinfo_t * itif, const tinfo_t * tif, uint64 offset, int * udm_idx, uint64 * bit_offset, bint return_member_type)
    ssize_t get_udm_by_tid(tinfo_t * tif, udm_t * udm, tid_t tid)
    ssize_t get_edm_by_tid(tinfo_t * tif, edm_t * edm, tid_t tid)
    bint get_type_by_tid(tinfo_t * tif, tid_t tid)
    tid_t get_tinfo_tid(tinfo_t * tif, bint force_tid)
    ssize_t get_tinfo_by_edm_name(tinfo_t * tif, const til_t * til, const char * mname)
    bint tinfo_get_func_frame(tinfo_t * tif, const func_t * pfn)
    bint calc_retloc(func_type_data_t * fti)
    bint calc_arglocs(func_type_data_t * fti)
    bint stroff_as_size(int plen, const tinfo_t & tif, asize_t value)  # -------------------------------------------------------------------...
    int visit_stroff_udms(udm_visitor_t & sfv, const tid_t * path, int plen, adiff_t * disp, bint appzero)  # -------------------------------------------------------------------...
    bint is_one_bit_mask(uval_t mask)  # -------------------------------------------------------------------...
    tinfo_t remove_pointer(const tinfo_t & tif)  # ::BT_PTR: If the current type is a pointer, return the pointed obje...
    bint func_has_stkframe_hole(ea_t ea, const func_type_data_t & fti)  # Looks for a hole at the beginning of the stack arguments. Will make...
    int lower_type(til_t * til, tinfo_t * tif, const char * name, lowertype_helper_t * _helper)  # -------------------------------------------------------------------...
    int replace_ordinal_typerefs(til_t * til, tinfo_t * tif)  # Replace references to ordinal types by name references. This functi...
    void begin_type_updating(update_type_t utp)  # Mark the beginning of a large update operation on the types. Can be...
    void end_type_updating(update_type_t utp)  # Mark the end of a large update operation on the types (see begin_ty...
    tid_t get_named_type_tid(const char * name)  # Get named local type TID
    uint32 get_tid_ordinal(tid_t tid)  # Get type ordinal number for TID
    ssize_t get_udm_by_fullname(udm_t * udm, const char * fullname)  # Get udt member by full name
    tid_t create_enum_type(const char * enum_name, enum_type_data_t & ei, int enum_width, type_sign_t sign, bint convert_to_bitmask, const char * enum_cmt)  # Create type enum
    int calc_number_of_children(const argloc_t & loc, const tinfo_t & tif, bint dont_deref_ptr)  # Calculate max number of lines of a formatted c data, when expanded ...
    bint choose_named_type(til_symbol_t * out_sym, const til_t * root_til, const char * title, int ntf_flags, predicate_t * predicate)  # Choose a type from a type library.
    ssize_t visit_edms(const tinfo_t & tif, uint64 value, int nbytes, uchar serial, const int & visitor)  # Visit enum members having the specified value
